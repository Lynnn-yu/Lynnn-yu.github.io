[{"content":"JpaRepository 是 Spring Data JPA 中的一个接口，提供了对数据库实体进行CRUD（Create, Read, Update, Delete）操作的常用方法。它继承自 PagingAndSortingRepository 和 CrudRepository，并且提供了一些额外的 JPA 相关的功能。\n使用 JpaRepository 的基本步骤 1. 创建实体类 首先，你需要定义一个实体类并使用 @Entity 注解来标记它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 import javax.persistence.Entity; import javax.persistence.Id; @Entity public class User { @Id private Long id; private String name; private String email; // getters and setters } 2. 创建 JpaRepository 接口 你需要创建一个接口，并让它继承 JpaRepository，其中泛型参数为 \u0026lt;EntityClass, IDType\u0026gt;，即实体类的类型和其主键类型。\n1 2 3 4 5 import org.springframework.data.jpa.repository.JpaRepository; public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { // 你可以在这里添加自定义查询方法 } UserRepository 接口继承了 JpaRepository，这样你就可以直接使用很多内置的方法。\n3. 使用 JpaRepository 提供的内置方法 JpaRepository 为我们提供了很多内置的操作方法，比如：\nsave(S entity)：保存实体对象。 findById(ID id)：通过主键查找实体。 findAll()：获取所有实体。 deleteById(ID id)：通过主键删除实体。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; import java.util.Optional; @Service public class UserService { @Autowired private UserRepository userRepository; public List\u0026lt;User\u0026gt; getAllUsers() { return userRepository.findAll(); } public Optional\u0026lt;User\u0026gt; getUserById(Long id) { return userRepository.findById(id); } public User saveUser(User user) { return userRepository.save(user); } public void deleteUser(Long id) { userRepository.deleteById(id); } } 自定义查询方法 除了 JpaRepository 提供的内置方法，你还可以在接口中定义自定义查询方法，Spring Data JPA 会根据方法名称自动生成查询。\n例如：\n1 2 3 4 5 6 7 8 9 10 import java.util.List; public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { // 自定义方法：通过用户名查找用户 List\u0026lt;User\u0026gt; findByName(String name); // 自定义方法：通过邮箱查找用户 User findByEmail(String email); } JpaRepository 常见内置方法 save(S entity)：保存或更新实体。 delete(T entity)：删除实体。 findAll()：查询所有实体。 findById(ID id)：根据ID查找实体。 count()：返回实体总数。 existsById(ID id)：检查某个实体是否存在。 总结 JpaRepository 是一个非常强大的接口，能够简化很多数据库操作。通过它，你可以轻松地完成对数据库的增删改查，并且可以自定义查询方法，极大地提升了开发效率。\n","date":"2024-09-20T16:15:06+08:00","permalink":"https://lynnn-yu.github.io/p/spring-data-jpa-%E7%9A%84jparepository/","title":"Spring Data JPA 的JpaRepository"},{"content":"Floyd 判圈算法（Floyd’s Cycle Detection Algorithm） 什么是 Floyd 判圈算法？ Floyd 判圈算法，也叫 龟兔赛跑算法（Tortoise and Hare Algorithm），是一种用于检测链表中是否存在环的算法。该算法由 Robert W. Floyd 提出，旨在通过两个不同速度的指针遍历链表来判断链表是否存在循环。其时间复杂度为 O(n)，空间复杂度为 O(1)，因此在效率和资源占用方面非常优越。\n算法原理 Floyd 判圈算法使用两个指针：\n慢指针（Tortoise）：每次移动一步。 快指针（Hare）：每次移动两步。 如果链表中存在环，那么快指针和慢指针最终会在环中相遇。如果链表中不存在环，快指针会先到达链表的末端。\n主要步骤如下： 初始化两个指针：慢指针 slow 和快指针 fast 都指向链表的头部。 快指针每次移动两步，慢指针每次移动一步。 如果快指针和慢指针在某个时刻相遇，则说明链表中存在环。 如果快指针到达 null（链表的末尾），则说明链表中没有环。 代码实现 下面是使用 Python 实现的 Floyd 判圈算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def has_cycle(head): slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next # 慢指针每次移动一步 fast = fast.next.next # 快指针每次移动两步 if slow == fast: # 如果相遇，则存在环 return True return False # 如果遍历结束没有相遇，则不存在环 示例解释 假设我们有一个链表，如下所示：\n1 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; 2 (环) 在此例中，节点 5 指向节点 2，形成了一个环。使用上述代码，快慢指针最终会在环中相遇，从而检测出链表中存在环。\n算法复杂度分析 时间复杂度：O(n)，其中 n 是链表的节点数量。虽然快指针每次走两步，但整体仍然是线性时间复杂度，因为每个节点最多会被访问两次。 空间复杂度：O(1)，因为该算法只使用了两个额外的指针，不需要额外的空间存储其他数据。 应用场景 Floyd 判圈算法主要用于检测链表中的环，但它在其他问题中也能发挥作用，例如：\n图的遍历中用于检测循环路径。 编译器中检测循环依赖。 动态数据结构中检测重复模式或回路。 总结 Floyd 判圈算法是一种高效且简单的算法，适用于检测链表中的环。相比于其他算法，它的优势在于时间复杂度和空间复杂度的平衡。在解决链表环问题时，这个算法是首选之一。如果你正在处理链表结构或者需要在图结构中寻找循环，Floyd 算法将是一个强大的工具。\n","date":"0001-01-01T00:00:00Z","permalink":"https://lynnn-yu.github.io/p/floyd-%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/","title":"Floyd 判圈算法"},{"content":"Optional\u0026lt;T\u0026gt; 是 Java 8 引入的一个容器类，用来解决 null 引用的问题。它可以包含或不包含一个非空值。Optional 主要用于避免 NullPointerException，使代码更加安全和可读。\n创建 Optional 对象 有几种方式可以创建一个 Optional 对象：\n1. Optional.of(T value) 这个方法用于创建包含非空值的 Optional 对象。如果传入的值为 null，它会抛出 NullPointerException。\n1 Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); 2. Optional.ofNullable(T value) 这个方法允许传入一个可能为 null 的值。如果值为 null，它会返回一个空的 Optional 对象；否则返回一个包含该值的 Optional。\n1 Optional\u0026lt;String\u0026gt; optional = Optional.ofNullable(null); // 空的 Optional Optional\u0026lt;String\u0026gt; optional2 = Optional.ofNullable(\u0026#34;Hello\u0026#34;); // 包含 \u0026#34;Hello\u0026#34; 的 Optional 3. Optional.empty() 创建一个空的 Optional 对象，不包含任何值。\n1 Optional\u0026lt;String\u0026gt; optional = Optional.empty(); 使用 Optional 的常用方法 1. isPresent() 检查 Optional 是否包含值。如果值存在，返回 true，否则返回 false。\n1 2 3 4 Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); if (optional.isPresent()) { System.out.println(optional.get()); // 输出 \u0026#34;Hello\u0026#34; } 2. ifPresent(Consumer\u0026lt;? super T\u0026gt; action) 如果 Optional 中包含值，就执行给定的 Consumer 操作，否则不执行。\n1 optional.ifPresent(value -\u0026gt; System.out.println(value)); // 输出 \u0026#34;Hello\u0026#34; 3. orElse(T other) 如果 Optional 中包含值，返回该值；如果为空，则返回一个默认值。\n1 2 String value = optional.orElse(\u0026#34;Default Value\u0026#34;); System.out.println(value); // 输出 \u0026#34;Hello\u0026#34; 或 \u0026#34;Default Value\u0026#34; 4. orElseGet(Supplier\u0026lt;? extends T\u0026gt; other) 类似于 orElse()，但可以通过传递 Supplier 来动态生成默认值。\n1 2 String value = optional.orElseGet(() -\u0026gt; \u0026#34;Generated Value\u0026#34;); System.out.println(value); // 输出 \u0026#34;Hello\u0026#34; 或 \u0026#34;Generated Value\u0026#34; 5. orElseThrow(Supplier\u0026lt;? extends X\u0026gt; exceptionSupplier) 如果 Optional 中包含值，返回该值；如果为空，抛出自定义的异常。\n1 String value = optional.orElseThrow(() -\u0026gt; new IllegalArgumentException(\u0026#34;No value present\u0026#34;)); 6. get() 返回 Optional 中包含的值。如果为空，则抛出 NoSuchElementException。\n1 2 Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); System.out.println(optional.get()); // 输出 \u0026#34;Hello\u0026#34; 注意：使用 get() 之前应当确保 Optional 中有值，可以配合 isPresent() 或者 ifPresent() 来避免异常。\n7. map(Function\u0026lt;? super T,? extends U\u0026gt; mapper) 如果 Optional 中存在值，则对其应用 Function 并返回新的 Optional，否则返回空的 Optional。\n1 2 3 Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); Optional\u0026lt;Integer\u0026gt; length = optional.map(String::length); System.out.println(length.get()); // 输出 5 8. flatMap(Function\u0026lt;? super T, Optional\u0026lt;U\u0026gt;\u0026gt; mapper) 与 map() 类似，但 mapper 返回的是一个 Optional，而不是直接返回值，用于嵌套的 Optional 解包。\n1 2 3 Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); Optional\u0026lt;String\u0026gt; result = optional.flatMap(value -\u0026gt; Optional.of(value.toUpperCase())); System.out.println(result.get()); // 输出 \u0026#34;HELLO\u0026#34; 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.Optional; public class Main { public static void main(String[] args) { // 创建一个 Optional 包含 \u0026#34;Hello\u0026#34; Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); // 检查值是否存在 if (optional.isPresent()) { System.out.println(\u0026#34;Value is present: \u0026#34; + optional.get()); } // 使用 orElse 方法获取值或默认值 String value = optional.orElse(\u0026#34;Default Value\u0026#34;); System.out.println(\u0026#34;The value is: \u0026#34; + value); // 使用 map 转换值 Optional\u0026lt;Integer\u0026gt; length = optional.map(String::length); System.out.println(\u0026#34;Length of the string is: \u0026#34; + length.get()); // 使用 flatMap 链式操作 Optional\u0026lt;String\u0026gt; result = optional.flatMap(val -\u0026gt; Optional.of(val.toUpperCase())); System.out.println(\u0026#34;Uppercased value: \u0026#34; + result.get()); } } 总结 Optional 是一个非常有用的工具，可以有效避免 null 引用问题，增强代码的可读性和健壮性。通过合理使用 Optional 的各种方法，你可以更好地管理代码中的空值处理逻辑。\n","date":"0001-01-01T00:00:00Z","permalink":"https://lynnn-yu.github.io/p/java%E4%B8%AD%E7%9A%84optional%E7%B1%BB/","title":"Java中的Optional类"},{"content":"核心接口 一、 Collection 关键方法:\n基本操作：\nadd(E e): 向集合添加一个元素，如果集合因添加而改变（即添加成功），返回 true。 addAll(Collection\u0026lt;? extends E\u0026gt; c): 将指定集合中的所有元素添加到此集合（可选操作）。 clear(): 移除此集合中的所有元素（可选操作）。 contains(Object o): 如果此集合包含指定的元素，则返回 true。 containsAll(Collection\u003c?\u003e c): 如果此集合包含指定集合中的所有元素，则返回 true。 isEmpty(): 如果此集合不包含元素，则返回 true。 iterator(): 返回在此集合的元素上进行迭代的迭代器。 remove(Object o): 从此集合中移除一个元素的单个实例，如果存在的话（可选操作）。 removeAll(Collection\u003c?\u003e c): 移除此集合中那些也包含在指定集合中的所有元素（可选操作）。 retainAll(Collection\u003c?\u003e c): 仅保留此集合中那些也包含在指定集合的元素（可选操作）。 size(): 返回此集合中的元素数。 toArray(): 返回包含此集合中所有元素的数组。 toArray(T[] a): 返回包含此集合中所有元素的数组；返回数组的运行时类型是指定数组的类型。 扩展操作：\nstream(): 返回一个顺序流，其元素是此集合的元素。 parallelStream(): 返回可能是并行的流，其元素是此集合的元素。 spliterator(): 在此集合中创建一个Spliterator。 1. List 概述: List 接口扩展自 Collection 接口，表示有序的集合。它允许重复的元素并且可以精确控制每个元素的位置。\n关键方法:\n基本操作：\nget(int index): 返回列表中指定位置的元素。 set(int index, E element): 替换列表中指定位置的元素，并返回之前在该位置的元素。 add(int index, E element): 在列表的指定位置插入指定元素（可选操作）。 remove(int index): 移除列表中指定位置的元素，并返回该元素（可选操作）。 搜索操作：\nindexOf(Object o): 返回列表中首次出现的指定元素的索引，如果列表不包含此元素，则返回 -1。 lastIndexOf(Object o): 返回列表中最后出现的指定元素的索引，如果列表不包含此元素，则返回 -1。 视图操作：\nlistIterator(): 返回列表中元素的列表迭代器（在列表的所有元素上进行迭代）。 listIterator(int index): 返回列表中元素的列表迭代器，迭代器的起始位置是列表中指定的位置。 subList(int fromIndex, int toIndex): 返回列表中指定的 fromIndex（包含）和 toIndex（不包含）之间的视图。 主要实现: ArrayList, LinkedList, Vector.\n2. Set 概述: Set 接口也是扩展自 Collection，代表没有重复元素的集合。\n关键方法: 与 Collection 接口共享大多数方法，没有额外的特殊方法，但强调了不允许有重复元素的特性。\n例如：\nadd(E e)：添加一个元素 e 到集合中，如果集合已经包含了该元素，则不进行添加操作，并且返回 false。这与 Collection 接口的 add 方法不同，后者允许添加重复的元素。 equals(Object o) 和 hashCode()：Set 接口也特别重视这两个方法的实现，以保持与 Set 语义的一致性。这意味着两个 Set 对象相等的条件是它们包含相同的元素。 主要实现: HashSet, LinkedHashSet, TreeSet.\n3. Queue 概述: Queue 接口扩展自 Collection 用于存储一组元素，元素的添加和移除遵循特定的顺序，比如先进先出（FIFO）。\n关键方法:\n添加元素：\noffer(E e): 尝试将元素 e 添加到队列中。如果成功，则返回 true；如果由于容量限制无法添加，则返回 false。这提供了一种比 add(E e) 更优雅的方式来添加元素，因为 add 方法在无法添加元素时会抛出异常。 移除元素：\npoll(): 移除并返回队列头部的元素。如果队列为空，返回 null。这是一个非阻塞的队列操作，不会抛出异常。 remove(): 从队列中移除并返回头部元素。这个方法与 poll 的区别在于，如果队列为空，它会抛出 NoSuchElementException。 检查元素：\npeek(): 检索但不移除队列的头部元素。如果队列为空，则返回 null。这个方法允许用户在不改变队列状态的情况下查看队列的头部元素。 element(): 检索但不移除队列的头部元素。这个方法与 peek 的区别在于，如果队列为空，它会抛出 NoSuchElementException。 主要实现: LinkedList, PriorityQueue.\n二、 Map 概述: Map 不是 Collection 接口的一部分，它表示键值对的映射。每个键最多只能映射到一个值。\n关键方法:\n基本操作：\nput(K key, V value): 将指定的值与此映射中的指定键关联（可选操作）。如果映射以前包含了该键的映射，则旧值将被替换。 get(Object key): 返回指定键所映射的值，如果此映射不包含该键的映射关系，则返回 null。 remove(Object key): 如果存在一个键的映射关系，则将其从映射中移除（可选操作）。 批量操作：\nputAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m): 将所有的映射关系从指定的映射复制到此映射中（可选操作）。 clear(): 从此映射中移除所有的映射关系（可选操作）。 查询操作：\ncontainsKey(Object key): 如果此映射包含指定键的映射关系，则返回 true。 containsValue(Object value): 如果此映射将一个或多个键映射到指定值，则返回 true。 isEmpty(): 如果此映射不包含键-值映射关系，则返回 true。 size(): 返回此映射中的键-值映射关系的数量。 视图操作：\nkeySet(): 返回此映射中包含的键的 Set 视图。 values(): 返回此映射中包含的值的 Collection 视图。 entrySet(): 返回此映射中包含的映射关系的 Set 视图。该 Set 中的每个元素都是一个实现了 Map.Entry 接口的键值对对象。 Map.Entry 接口\nMap 还定义了一个内部接口 Map.Entry，这个接口表示 Map 中的一个键值对（一个映射关系）。\ngetKey(): 返回与此项对应的键。 getValue(): 返回与此项对应的值。 setValue(V value): 将此项的值替换为指定的值（可选操作）。 主要实现: HashMap, TreeMap, LinkedHashMap.\n数据结构 1. 数组 (Array) 静态数组：Java 中的数组是固定长度的数据结构，用于存储相同类型的数据。它们提供快速的索引访问，但大小不可变。\n常用方法：\n虽然数组自身的方法有限，Java 类库提供了一些工具类，如 Arrays 类，以支持更复杂的数组操作：\n排序: Arrays.sort(array) 方法可以对数组进行排序。 搜索: 使用 Arrays.binarySearch(sortedArray, key) 在已排序的数组中查找特定的元素。 比较: Arrays.equals(array1, array2) 用来比较两个数组的内容是否相等。 填充: Arrays.fill(array, value) 方法可以将特定的值赋给数组中的每个元素。 转换为列表: Arrays.asList(array) 将数组转换为一个固定大小的列表。 复制: Arrays.copyOf(array, newLength) 复制数组到新的数组，可以指定新数组的长度。 打印: Arrays.toString(array) 返回数组内容的字符串表示，便于打印输出。 2. 动态数组 (ArrayList) 1 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 动态扩容：是 List 接口的一个实现。基于数组实现，但能动态地扩展和缩减大小。主要优点是提供快速的随机访问，同时允许在列表末尾高效地添加或删除元素。\n常用方法：\nadd(E e): 在列表末尾添加一个元素，返回 true。\nadd(int index, E element): 在列表的指定位置添加一个元素。\nremove(Object o): 删除列表中首次出现的指定元素，如果列表包含该元素则返回 true。\nremove(int index): 删除指定索引处的元素，返回被删除的元素。\nget(int index): 返回列表中指定位置的元素。\nset(int index, E element): 替换指定索引处的元素，返回之前在该位置的元素。\nsize(): 返回列表中的元素数。\nisEmpty(): 检查列表是否为空，为空返回 true。\ncontains(Object o): 如果列表包含指定的元素，则返回 true。\nindexOf(Object o): 返回列表中首次出现的指定元素的索引，如果此列表不包含该元素，则返回 -1。\nlastIndexOf(Object o): 返回列表中最后出现的指定元素的索引，如果列表不包含该元素，则返回 -1。\naddAll(Collection\u0026lt;? extends E\u0026gt; c): 将指定集合中的所有元素添加到列表的末尾。\naddAll(int index, Collection\u0026lt;? extends E\u0026gt; c): 将指定集合中的所有元素插入到列表中的指定位置。\nclear(): 移除列表中的所有元素。\nremoveAll(Collection\u003c?\u003e c): 移除列表中包含在指定集合中的所有元素。\nretainAll(Collection\u003c?\u003e c): 仅保留列表中那些也包含在指定集合中的元素。\niterator(): 返回一个在列表元素上进行迭代的迭代器。\nlistIterator(): 返回列表中元素的列表迭代器（可以从任意位置开始迭代）。\nforEach(Consumer\u0026lt;? super E\u0026gt; action): 对每个元素执行给定的操作，这是 Java 8 引入的方法，支持 Lambda 表达式。\ntoArray(): 返回一个包含列表中所有元素的数组。\ntoArray(T[] a): 返回一个包含列表中所有元素的数组；返回的数组的运行时类型是指定数组的类型。\n3. 链表 (LinkedList) 1 2 3 List\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); //或者，如果你需要使用 LinkedList 作为双端队列（deque）： Deque\u0026lt;Integer\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); 双向链表：是 List 接口的一个实现，也实现了 Deque 接口，使其能够作为一个双向链表使用。每个元素包含两个指针，分别指向前一个和后一个元素，使得在任何位置的插入和删除操作都很高效，尤其适用于实现队列和栈。\n常用方法：\nList：\nadd(E e): 将元素添加到列表末尾。\nadd(int index, E element): 在指定位置插入元素。\nget(int index): 访问指定位置的元素。\nset(int index, E element): 替换指定位置的元素，返回被替换的元素。\nremove(int index): 移除指定位置的元素，返回被移除的元素。\nremove(Object o): 删除列表中首次出现的指定元素。\niterator() 和 listIterator(): 提供顺序访问列表的迭代器。\nDeque：\noffer(E e): 在队列尾部添加元素，返回是否成功。\nofferFirst(E e) 和 offerLast(E e): 分别在队列的头部和尾部添加元素。\npoll() 和 pollFirst(): 移除并返回队列头部的元素；如果队列为空，则返回 null。\npollLast(): 移除并返回队列尾部的元素；如果队列为空，则返回 null。\npeek() 和 peekFirst(): 查看但不移除队列头部的元素；如果队列为空，则返回 null。\npeekLast(): 查看但不移除队列尾部的元素；如果队列为空，则返回 null。\npush(E e): 将元素推入栈顶（队列头部）。\npop(): 移除并返回栈顶（队列头部）的元素。\n使用场景：\nList 使用场景: 当你需要频繁地在列表中间插入或删除元素时，使用 LinkedList 比 ArrayList 更高效。 Deque 使用场景: 当你需要在两端动态地添加或移除元素，或者实现栈的行为时，LinkedList 提供了必要的操作。 4. 栈 (Stack) 1 Stack\u0026lt;String\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); 后进先出 (LIFO)：继承自 Vector 类继承自 Vector 类。栈是一种后进先出的数据结构，适合处理具有嵌套结构的数据，如表达式求值和语法解析。\n常用方法：\npush(E item): 将一个元素压入栈顶。此方法将元素添加到栈的顶部，并返回压入的元素。 pop(): 移除栈顶元素，并作为此函数的值返回该对象。 peek(): 查看栈顶对象而不移除它。返回栈顶元素，但不从栈中移除它。 empty(): 测试堆栈是否为空。 search(Object o): 返回对象在堆栈中的位置，以 1 为基数。如果对象 o 作为一个项存在于此堆栈中，则返回距离栈顶最近的位置；栈顶位置为 1。如果不在栈中，则返回 -1。 尽管 Stack 类在 Java 中广泛使用，但 Java 官方文档推荐更倾向于使用 Deque 接口来实现栈的功能，例如通过 ArrayDeque 类，因为 Stack 类本身继承自 Vector，其所有的操作都是同步的，这可能在不需要线程安全的应用场景中导致不必要的性能损失。使用 ArrayDeque 可以获得更好的性能：\n1 2 3 4 Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push(1); // 压入元素 Integer top = stack.peek(); // 查看栈顶元素 Integer element = stack.pop(); // 移除栈顶元素 5. 优先队列/堆 (PriorityQueue) 基于堆结构：元素按优先级排序，允许快速访问当前最高（或最低）优先级的元素，常用于任务调度和带优先级的数据处理。\n常用方法：\nadd(E e) / offer(E e): 向优先队列添加一个元素。这两个方法在功能上几乎相同，用于在优先队列中插入元素。\npeek(): 返回队列头部的元素而不移除它，如果队列为空，则返回 null。\nelement(): 类似于 peek()，但如果队列为空时会抛出异常。\npoll(): 移除并返回队列头部的元素，如果队列为空，则返回 null。\nremove(): 类似于 poll()，但如果队列为空时会抛出异常。\nremove(Object o): 移除队列中的一个特定元素，返回 true 如果元素被成功移除。\nsize(): 返回队列中的元素数量。\nisEmpty(): 检查队列是否为空，为空则返回 true。\nclear(): 清除队列中的所有元素，使队列变为空。\ncomparator(): 返回当前用于比较队列元素的比较器，如果队列按照元素的自然顺序排序，则可能返回 null。\nPriorityQueue 是基于二叉堆实现的，这使得它在插入和删除最小元素（或根据 Comparator 定义的其他顺序）的操作中非常高效，这些操作的时间复杂度为 O(log n)。这种数据结构适合用于需要快速访问最“优先”元素的场合，如任务调度、带优先级的任务处理等。\n6. 哈希表 (HashSet/HashMap) 1 2 HashSet\u0026lt;Type\u0026gt; setName = new HashSet\u0026lt;\u0026gt;(); HashMap\u0026lt;KeyType, ValueType\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 基于哈希算法：提供快速的数据存取，适用于需要快速查找、插入和删除的场景。无序，不保证元素的顺序。不允许重复元素。\nHashSet常用方法：\nadd(E e): 向集合中添加一个元素，如果元素已存在则不进行添加。\ncontains(Object o): 检查集合是否包含指定的元素，返回 true 或 false。\nremove(Object o): 从集合中移除指定元素，返回 true 如果元素存在且成功移除，返回 false 如果元素不存在。\nsize(): 返回集合中元素的数量。\nisEmpty(): 检查集合是否为空，返回 true 如果集合为空。\nclear(): 清空集合中的所有元素，使集合变为空。\niterator(): 返回集合的迭代器，用于遍历集合中的元素。\nHashMap常用方法：\nput(K key, V value): 将指定的键与值关联。如果键已存在，则更新其对应的值。\nputAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m): 将指定映射中的所有键值对添加到此映射中。\nget(Object key): 根据指定键返回对应的值，如果键不存在则返回 null。\ncontainsKey(Object key): 检查映射是否包含指定的键，返回 true 或 false。\ncontainsValue(Object value): 检查映射是否包含指定的值，返回 true 或 false。\nremove(Object key): 移除指定键及其对应的值，返回被移除的值（如果存在），否则返回 null。\nsize(): 返回映射中键值对的数量。\nisEmpty(): 检查映射是否为空，返回 true 如果映射为空。\nclear(): 清空映射中的所有键值对。\nkeySet(): 返回映射中所有键的集合。\nvalues(): 返回映射中所有值的集合。\nentrySet(): 返回映射中所有键值对的集合（Map.Entry 对象）。\n7. 红黑树 (TreeSet/TreeMap) 1 2 TreeSet\u0026lt;Type\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); TreeMap\u0026lt;KeyType, ValueType\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); 红黑树(自平衡的二叉查找树)：保证数据元素按照排序规则组织，支持有序遍历和快速搜索。不允许重复元素。\nTreeSet常用方法：\nadd(E e): 向集合中添加一个元素，如果元素已存在，则不进行添加。\ncontains(Object o): 检查集合是否包含指定的元素，返回 true 或 false。\nremove(Object o): 从集合中移除指定元素，返回 true 如果元素存在且成功移除，返回 false 如果元素不存在。\nfirst(): 返回集合中的第一个元素（最小元素）。\nlast(): 返回集合中的最后一个元素（最大元素）。\nhigher(E e): 返回严格大于指定元素的下一个元素。\nlower(E e): 返回严格小于指定元素的上一个元素。\nsubSet(E fromElement, E toElement): 返回指定范围内的视图，包含从 fromElement 到 toElement（不包含 toElement）。\nheadSet(E toElement): 返回小于 toElement 的所有元素的视图。\ntailSet(E fromElement): 返回大于或等于 fromElement 的所有元素的视图。\nsize(): 返回集合中元素的数量。\nisEmpty(): 检查集合是否为空，返回 true 如果集合为空。\nclear(): 清空集合中的所有元素，使集合变为空。\niterator(): 返回集合的迭代器，用于按升序遍历集合中的元素。\nTreeMap常用方法：\nput(K key, V value): 将指定的键与值关联。如果键已存在，则更新其对应的值。\nputAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m): 将指定映射中的所有键值对添加到此映射中。\nget(Object key): 根据指定键返回对应的值，如果键不存在则返回 null。\ncontainsKey(Object key): 检查映射是否包含指定的键，返回 true 或 false。\ncontainsValue(Object value): 检查映射是否包含指定的值，返回 true 或 false。\nremove(Object key): 移除指定键及其对应的值，返回被移除的值（如果存在），否则返回 null。\nfirstKey(): 返回映射中的第一个键（最小键）。\nlastKey(): 返回映射中的最后一个键（最大键）。\nhigher(K key): 返回严格大于指定键的下一个键。\nlower(K key): 返回严格小于指定键的上一个键。\nsubMap(K fromKey, K toKey): 返回指定范围内的视图，包含从 fromKey 到 toKey（不包含 toKey）。\nheadMap(K toKey): 返回小于 toKey 的所有键值对的视图。\ntailMap(K fromKey): 返回大于或等于 fromKey 的所有键值对的视图。\nsize(): 返回映射中键值对的数量。\nisEmpty(): 检查映射是否为空，返回 true 如果映射为空。\nclear(): 清空映射中的所有键值对。\nkeySet(): 返回映射中所有键的集合。\nvalues(): 返回映射中所有值的集合。\nentrySet(): 返回映射中所有键值对的集合（Map.Entry 对象）。\n8. 链式哈希集合(LinkedHashSet) 1 LinkedHashSet\u0026lt;Type\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); 其中，Type 是要存储的元素类型（如 Integer、String 等）\n**基于哈希表和双向链表：**保持元素的插入顺序。不允许重复元素。\n常用方法：\nadd(E e): 向集合中添加一个元素，如果元素已存在则不进行添加。\ncontains(Object o): 检查集合是否包含指定的元素，返回 true 或 false。\nremove(Object o): 从集合中移除指定元素，返回 true 如果元素存在且成功移除，返回 false 如果元素不存在。\nsize(): 返回集合中元素的数量。\nisEmpty(): 检查集合是否为空，返回 true 如果集合为空。\nclear(): 清空集合中的所有元素，使集合变为空。\niterator(): 返回集合的迭代器，用于按插入顺序遍历集合中的元素。\n9. 图 (Graph) 节点加边的集合：Java 标准库中没有内置的 Graph 类。如果需要使用图数据结构，通常需要自己实现一个图类，或者使用第三方库（如 JGraphT）来处理图的操作。自定义图类可以根据具体需求（如无向图、有向图、加权图等）进行实现和扩展。\n图的简单实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import java.util.*; class Graph\u0026lt;V\u0026gt; { private Map\u0026lt;V, List\u0026lt;V\u0026gt;\u0026gt; adjacencyList; public Graph() { adjacencyList = new HashMap\u0026lt;\u0026gt;(); } // 添加顶点 public void addVertex(V vertex) { adjacencyList.putIfAbsent(vertex, new LinkedList\u0026lt;\u0026gt;()); } // 添加边 public void addEdge(V vertex1, V vertex2) { addVertex(vertex1); addVertex(vertex2); adjacencyList.get(vertex1).add(vertex2); adjacencyList.get(vertex2).add(vertex1); // 无向图 } // 获取所有顶点 public Set\u0026lt;V\u0026gt; getVertices() { return adjacencyList.keySet(); } // 获取所有边 public List\u0026lt;String\u0026gt; getEdges() { List\u0026lt;String\u0026gt; edges = new ArrayList\u0026lt;\u0026gt;(); for (V vertex : adjacencyList.keySet()) { for (V neighbor : adjacencyList.get(vertex)) { edges.add(vertex + \u0026#34; - \u0026#34; + neighbor); } } return edges; } } // 使用示例 public class Main { public static void main(String[] args) { Graph\u0026lt;String\u0026gt; graph = new Graph\u0026lt;\u0026gt;(); graph.addVertex(\u0026#34;A\u0026#34;); graph.addVertex(\u0026#34;B\u0026#34;); graph.addEdge(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;); graph.addEdge(\u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;); System.out.println(\u0026#34;Vertices: \u0026#34; + graph.getVertices()); System.out.println(\u0026#34;Edges: \u0026#34; + graph.getEdges()); } } ","date":"0001-01-01T00:00:00Z","permalink":"https://lynnn-yu.github.io/p/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E4%B8%80%E8%A7%88/","title":"Java集合框架：数据结构及常用操作一览"},{"content":"在 Spring MVC 中，Model 用于在控制器和视图之间传递数据。当你在控制器方法中使用 model.addAttribute() 添加数据时，这些数据会自动被传递到视图（如 Thymeleaf、JSP 等），并在视图中通过模型属性的名字进行访问。\nModel 传参的具体流程 1.控制器方法传递数据到视图：\n在控制器中，使用 model.addAttribute() 方法将一个对象添加到 Model。 Spring MVC 会将这个对象作为请求属性传递给视图（比如 Thymeleaf 模板）。 视图渲染时，可以通过模型中提供的属性来访问并显示数据。 示例代码： 1 2 3 4 5 6 @GetMapping(\u0026#34;/types/input\u0026#34;) public String input(Model model) { // 创建一个新的 Type 对象，并通过 addAttribute 将其放入 Model 中 model.addAttribute(\u0026#34;type\u0026#34;, new Type()); return \u0026#34;admin/types-input\u0026#34;; // 返回视图名 } ​ 在上面的代码中，model.addAttribute(\u0026quot;type\u0026quot;, new Type()) 将一个 Type 对象存储在模型中，键名为 \u0026quot;type\u0026quot;。\n2.视图中获取和使用模型数据：\n在视图模板中（例如 Thymeleaf），你可以通过指定的键名来访问 Model 中的数据。键名是 addAttribute 中的第一个参数（如 \u0026quot;type\u0026quot;），通过这个键名，视图可以使用绑定的对象进行显示或表单字段的初始化。 示例 Thymeleaf 视图（admin/types-input.html）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Type Input\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Input Type\u0026lt;/h1\u0026gt; \u0026lt;!-- 表单绑定到 type 对象的 name 属性 --\u0026gt; \u0026lt;form th:action=\u0026#34;@{/types/save}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Type Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; th:field=\u0026#34;*{name}\u0026#34; placeholder=\u0026#34;Enter type name\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; th:field=\u0026quot;*{name}\u0026quot; 这里的 *{name} 表示从 Model 中绑定的 type 对象的 name 属性。 Spring MVC 自动将 Type 对象放入 Model 中，所以 Thymeleaf 模板能够直接访问 Type 对象的属性。 当页面加载时，th:field 会预先将 type.name 的值显示在表单中（如果有值）。在提交表单时，输入的数据会绑定到 Type 对象的 name 属性。 Model 的传递过程 1. 数据存入 Model： 在控制器方法中调用 model.addAttribute(\u0026quot;type\u0026quot;, new Type())，将键值对存入 Model。 这里 \u0026quot;type\u0026quot; 是键，new Type() 是对应的值（对象）。 2. 传递到视图： Spring MVC 将模型中的所有键值对放入 HTTP 请求的属性中，传递到视图层。 模型中的数据自动与视图解析器（如 Thymeleaf、JSP）关联，视图模板可以通过模型中的键名来访问对象。 3. 视图访问模型数据： 在视图模板中，可以通过 type 键名直接访问绑定的 Type 对象，并且可以使用这个对象来填充表单字段、显示数据，或进行其他操作。 具体示例：完整的控制器与视图交互 1. 控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Controller public class TypeController { @GetMapping(\u0026#34;/types/input\u0026#34;) public String input(Model model) { // 创建一个新的 Type 对象，传递给视图 model.addAttribute(\u0026#34;type\u0026#34;, new Type()); return \u0026#34;admin/types-input\u0026#34;; // 返回视图名称 } @PostMapping(\u0026#34;/types/save\u0026#34;) public String save(@ModelAttribute Type type) { // 在这里处理保存操作，Type 对象会自动绑定表单提交的数据 System.out.println(\u0026#34;Saved Type: \u0026#34; + type.getName()); return \u0026#34;redirect:/types/list\u0026#34;; // 重定向到类型列表页面 } } 2. 视图模板（admin/types-input.html） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Type Input\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Input Type\u0026lt;/h1\u0026gt; \u0026lt;!-- 使用 th:field 来绑定 type 对象的 name 属性 --\u0026gt; \u0026lt;form th:action=\u0026#34;@{/types/save}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Type Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; th:field=\u0026#34;*{name}\u0026#34; placeholder=\u0026#34;Enter type name\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 总结 Model 在控制器和视图之间扮演了数据传递的桥梁。 在控制器中，你可以通过 model.addAttribute() 将数据传递给视图，视图模板可以通过指定的键名访问这些数据。 这种方式通常用于表单提交的场景，视图层会根据控制器传递的对象进行表单数据的绑定和显示。 ","date":"0001-01-01T00:00:00Z","permalink":"https://lynnn-yu.github.io/p/spring-mvc-%E4%B8%AD%E7%9A%84model/","title":"Spring MVC 中的Model"}]