[{"content":"回溯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class PermutationGenerator { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); backtrack(list, new ArrayList\u0026lt;\u0026gt;(), nums); return list; } private void backtrack(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; list, List\u0026lt;Integer\u0026gt; tempList, int[] nums) { // 终止条件 if (tempList.size() == nums.length) { // 说明找到一组组合 list.add(new ArrayList\u0026lt;\u0026gt;(tempList)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { // 因为不能有重复的，所以有重复的就不能选 if (tempList.contains(nums[i])) { continue; } // 选择当前值 tempList.add(nums[i]); // 递归 backtrack(list, tempList, nums); // 撤销选择 tempList.remove(tempList.size() - 1); } } } 深度优先搜索 1.递归(回溯思想) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class GraphPathFinder { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); public void dfs(图，目前搜索的节点) { if (剪枝条件) return; // 剪枝 if (终止条件) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); // 存放结果 return; } for (选择：本层节点所连接的其他节点) { 处理节点;（做选择） dfs(图，选择的节点); // 递归 path.remove(path.size() - 1); // 回溯（撤销选择） } } } 2.栈（见BFS模板，改为栈实现） 广度优先搜索 1.队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class GraphTraversal { private static final int[][] dir = { {0, 1}, // 右 {1, 0}, // 下 {-1, 0}, // 上 {0, -1} // 左 }; public void bfs(char[][] grid, boolean[][] visited, int x, int y) { Queue\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // 定义队列 queue.offer(new int[]{x, y}); // 起始节点加入队列 visited[x][y] = true; // 立刻标记为访问过的节点 while (!queue.isEmpty()) { // 开始遍历队列里的元素 int[] cur = queue.poll(); // 从队列取元素 int curx = cur[0]; int cury = cur[1]; // 当前节点坐标 for (int i = 0; i \u0026lt; 4; i++) { // 向四个方向遍历 int nextx = curx + dir[i][0]; int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标 // 检查坐标是否越界 if (nextx \u0026lt; 0 || nextx \u0026gt;= grid.length || nexty \u0026lt; 0 || nexty \u0026gt;= grid[0].length) { continue; // 坐标越界，跳过 } if (!visited[nextx][nexty]) { // 如果节点没被访问过 queue.offer(new int[]{nextx, nexty}); // 添加该节点为下一轮要遍历的节点 visited[nextx][nexty] = true; // 标记为已访问 } } } } } 例子：岛屿数量 题目描述 给定一个二维网格，其中 1 代表陆地，0 代表水，计算岛屿的数量。相邻的陆地（上下左右相连）算作同一个岛屿。\n深度优先搜索 (DFS) 实现 方法 1：递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class IslandCounter { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) return 0; int count = 0; for (int i = 0; i \u0026lt; grid.length; i++) { for (int j = 0; j \u0026lt; grid[0].length; j++) { if (grid[i][j] == \u0026#39;1\u0026#39;) { dfs(grid, i, j); // 进行DFS count++; } } } return count; } private void dfs(char[][] grid, int x, int y) { if (x \u0026lt; 0 || x \u0026gt;= grid.length || y \u0026lt; 0 || y \u0026gt;= grid[0].length || grid[x][y] == \u0026#39;0\u0026#39;) { return; // 越界或水域，返回 } grid[x][y] = \u0026#39;0\u0026#39;; // 标记为已访问 // 递归访问上下左右 dfs(grid, x + 1, y); dfs(grid, x - 1, y); dfs(grid, x, y + 1); dfs(grid, x, y - 1); } } 方法 2：栈实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import java.util.Stack; public class IslandCounter { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) return 0; int count = 0; for (int i = 0; i \u0026lt; grid.length; i++) { for (int j = 0; j \u0026lt; grid[0].length; j++) { if (grid[i][j] == \u0026#39;1\u0026#39;) { dfsStack(grid, i, j); // 进行栈实现的DFS count++; } } } return count; } private void dfsStack(char[][] grid, int x, int y) { Stack\u0026lt;int[]\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(new int[]{x, y}); grid[x][y] = \u0026#39;0\u0026#39;; // 标记为已访问 while (!stack.isEmpty()) { int[] cur = stack.pop(); int curx = cur[0]; int cury = cur[1]; // 访问上下左右 if (curx + 1 \u0026lt; grid.length \u0026amp;\u0026amp; grid[curx + 1][cury] == \u0026#39;1\u0026#39;) { stack.push(new int[]{curx + 1, cury}); grid[curx + 1][cury] = \u0026#39;0\u0026#39;; // 标记为已访问 } if (curx - 1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[curx - 1][cury] == \u0026#39;1\u0026#39;) { stack.push(new int[]{curx - 1, cury}); grid[curx - 1][cury] = \u0026#39;0\u0026#39;; // 标记为已访问 } if (cury + 1 \u0026lt; grid[0].length \u0026amp;\u0026amp; grid[curx][cury + 1] == \u0026#39;1\u0026#39;) { stack.push(new int[]{curx, cury + 1}); grid[curx][cury + 1] = \u0026#39;0\u0026#39;; // 标记为已访问 } if (cury - 1 \u0026gt;= 0 \u0026amp;\u0026amp; grid[curx][cury - 1] == \u0026#39;1\u0026#39;) { stack.push(new int[]{curx, cury - 1}); grid[curx][cury - 1] = \u0026#39;0\u0026#39;; // 标记为已访问 } } } } 广度优先搜索 (BFS) 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import java.util.LinkedList; import java.util.Queue; public class IslandCounter { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) return 0; int count = 0; for (int i = 0; i \u0026lt; grid.length; i++) { for (int j = 0; j \u0026lt; grid[0].length; j++) { if (grid[i][j] == \u0026#39;1\u0026#39;) { bfs(grid, i, j); // 进行BFS count++; } } } return count; } private void bfs(char[][] grid, int x, int y) { Queue\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(new int[]{x, y}); grid[x][y] = \u0026#39;0\u0026#39;; // 标记为已访问 int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // 四个方向 while (!queue.isEmpty()) { int[] cur = queue.poll(); for (int[] dir : directions) { int nextx = cur[0] + dir[0]; int nexty = cur[1] + dir[1]; // 检查边界和水域 if (nextx \u0026gt;= 0 \u0026amp;\u0026amp; nextx \u0026lt; grid.length \u0026amp;\u0026amp; nexty \u0026gt;= 0 \u0026amp;\u0026amp; nexty \u0026lt; grid[0].length \u0026amp;\u0026amp; grid[nextx][nexty] == \u0026#39;1\u0026#39;) { queue.offer(new int[]{nextx, nexty}); // 加入队列 grid[nextx][nexty] = \u0026#39;0\u0026#39;; // 标记为已访问 } } } } } 总结 DFS 实现：提供了递归和栈的两种实现方式，遍历并标记岛屿中的所有 1。 BFS 实现：使用队列进行层次遍历，同样标记所有相连的 1。 ","date":"2024-11-04T14:43:49+08:00","image":"https://lynnn-yu.github.io/%20","permalink":"https://lynnn-yu.github.io/p/%E5%9B%9E%E6%BA%AF-%E6%B7%B1%E6%90%9Cdfs-%E5%B9%BF%E6%90%9Cbfs/","title":"回溯+深搜DFS+广搜BFS"},{"content":"1、RLHF/PPO/DPO是什么？ RLHF（Reinforcement Learning from Human Feedback，基于人类反馈的强化学习）是一种机器学习（ML）技术，它利用人类反馈来优化 ML 模型，从而更有效地进行自我学习。\n即：收集符合人类价值偏好的数据集，对LLM进行微调，使其回答向人类价值观对齐。\n《Learning to summarize from human feedback》\nPPO（Proximal Policy Optimization）是OpenAI在2017提出的一种强化学习算法，是基于策略优化的算法，用于训练能够最大化累积奖励的智能体。PPO算法通过在每次更新时限制新策略与旧策略之间的差异，从而更稳定地更新策略参数。这种方法有助于避免训练过程中出现的不稳定性和剧烈波动，使得算法更容易收敛并学习到更好的策略。\n即：PPO是RLHF实施用到的具体算法\n《Proximal Policy Optimization Algorithms》\nDPO（Direct Preference Optimization， 直接偏好优化）是一种稳定的、性能和计算成本轻量级的强化学习算法。通过利用奖励函数与最优策略之间的映射关系，证明这个受限的奖励最大化问题可以通过单阶段的策略训练来精确优化，本质上是在人类偏好数据上解决一个分类问题。\n即：DPO是相对于PPO更加稳定、低成本的强化学习方法\n《Direct Preference Optimization: Your Language Model is Secretly a Reward Model》\n2、为什么要使用RLHF/PPO/DPO？ LLM在预训练时是直接输入大量文本进行训练，根据当前token预测下一个token。那么当用户输入一段英文时，是继续编写下文 or 进行翻译 or 进行对话？，模型本身无法区分具体任务。因此需要指令微调，针对指定任务，可以针对性的优化LLM的性能。大部分LLM从功能上说到这里就足够了。\n但是对于一个成熟的LLM产品，不但功能要强，还不能胡编乱造，不能回答一些非法问题，不能触犯zzzq，因此RLHF就出现了。\nRLHF通过收集人类反馈数据（符合人类偏好的数据），训练出奖励模型，通过奖励模型评估LLM的答案，更新LLM权重，最终得到答案符合人类偏好的LLM。具体使用的策略就是PPO算法。\n但是RLHF是一个复杂且经常不稳定的过程，首先拟合反映人类偏好的奖励模型，然后使用强化学习微调大型无监督 LM，以最大化这种估计奖励，而不会偏离原始模型太远。且PPO需要收集大量人类偏好数据、需要训练奖励模型、RLHF需要同时加载多个模型进行训练，训练难度较大。\n提出了使用DPO的方式进行训练。\n3. PPO（Proximal Policy Optimization，近端策略优化） PPO（Proximal Policy Optimization，近端策略优化）是一种用于强化学习的算法，主要目的是在训练过程中保证策略更新的稳定性和效率。\n简单来说，PPO通过限制每次策略更新的幅度，避免模型在学习过程中发生大幅度的性能波动，从而使训练更加稳定。它主要用于优化策略，即帮助智能体根据环境中的反馈（奖励）来不断改进它的行动策略，使其能够更好地完成任务。\nPPO的关键特点： 策略更新的限制：每次更新时，PPO会确保新的策略不会偏离旧策略太远，防止策略更新过大带来的不稳定性。 计算高效：PPO相比其他复杂的强化学习算法（如TRPO）更简单，同时还能保证较好的效果，因而在大语言模型的强化学习（如RLHF）中被广泛应用。 PPO的具体算法： PPO（Proximal Policy Optimization）通过引入剪切（clipping）和信赖域约束来限制每次策略更新的幅度，确保模型在训练过程中保持稳定性。下面是PPO如何具体限制更新幅度的详细解释：\n1. 策略比值（Ratio of Policies） PPO基于强化学习中的策略梯度方法，目的是通过迭代优化策略，使得智能体能够更好地根据环境作出决策。在每次更新时，PPO引入了一个策略比值（ratio of policies），用来表示新策略与旧策略在同一状态下选择相同行动的概率比：\n$$ r(\\theta) = \\frac{\\pi_{\\theta_{\\text{new}}}(a|s)}{\\pi_{\\theta_{\\text{old}}}(a|s)} $$其中：\n$\\pi_{\\theta_{\\text{new}}}(a|s)$ 是当前新策略（参数为$\\theta_{\\text{new}}$）在状态 $s$ 下选择动作 $a$ 的概率。 $\\pi_{\\theta_{\\text{old}}}(a|s)$ 是旧策略（参数为$\\theta_{\\text{old}}$）在同一状态下选择动作 $a$ 的概率。 这个比值 $r(\\theta)$ 反映了新旧策略在当前状态和动作下的差异。\n2. 限制策略更新的幅度：剪切（Clipping）机制 PPO的核心思想是防止新策略与旧策略差异过大，因此它使用剪切（clipping）机制来限制策略更新的幅度。具体做法是：\n$$ L^{\\text{CLIP}}(\\theta) = \\min \\left( r(\\theta) \\cdot \\hat{A}(s,a), \\, \\text{clip}(r(\\theta), 1 - \\epsilon, 1 + \\epsilon) \\cdot \\hat{A}(s,a) \\right) $$其中：\n$ \\hat{A}(s, a) $ 是优势函数（advantage function），表示在给定状态 $s$ 下选择动作 $a $的优势（即相对于其他可能的动作，这个动作有多好）。 $\\epsilon$ 是一个超参数，通常取值较小（例如 0.1 或 0.2），用于控制策略更新的幅度。 PPO通过这个公式的最小值操作，确保策略更新时的比值 $r(\\theta)$ 不会偏离 1 太多。如果 $r(\\theta)$ 的变化超过了 $1 + \\epsilon$ 或小于 $1 - \\epsilon$，更新就会被限制在 $[1 - \\epsilon, 1 + \\epsilon]$ 之间。这种限制能够防止策略的更新过大，避免强化学习过程中出现不稳定的情况。\n简化解释：\n如果新策略和旧策略的差异太大（即 $r(\\theta)$ 过大或过小），模型就会限制更新幅度，不允许它过度偏离原来的策略。 剪切机制有效地防止了过大更新，从而使策略的每次改进更加平稳。 3. 信赖域约束（Trust Region Constraint）与 PPO 的差异 在 PPO 之前，有一种更复杂的策略优化算法叫做 TRPO（Trust Region Policy Optimization），其通过引入信赖域约束来防止策略更新过大。TRPO 通过一个较为复杂的优化过程来确保新旧策略之间的“距离”（通常以 KL散度度量）不会超过某个阈值。\n相比之下，PPO的剪切机制是一种更简单的方式实现类似的目标，直接通过限制策略比值 $r(\\theta)$ 的变化范围来控制更新的幅度。这种方式虽然相对简单，但效果显著，且计算效率更高，因此被广泛采用。\n4. PPO优化目标 最终的优化目标是通过最大化“裁剪后的目标函数”（即上面提到的 $\\min$ 操作结果）来更新策略。这个目标函数鼓励策略在优势较大的状态下进行更新，但同时避免了策略变化过大可能带来的不稳定性。\n5. 总结 PPO如何限制更新幅度：\n策略比值：通过计算新旧策略在相同行动上的概率比，衡量策略的变化。 剪切机制：如果策略比值超出了允许范围（通常设为 $[1 - \\epsilon, 1 + \\epsilon]$），则剪切比值，限制策略更新幅度。 效果：这种方法使得策略每次更新时不会变化太大，保持了强化学习过程的稳定性，并且相比更复杂的 TRPO，PPO 的效率更高，适用于大规模模型训练。 因此，PPO 是一种平衡了策略改进速度与训练稳定性的强化学习算法，通过限制策略的更新幅度，确保每次训练迭代都在“信赖域”内进行，避免策略偏离太远导致不稳定的情况。\nDPO（Direct Preference Optimization，直接偏好优化） DPO（Direct Preference Optimization，直接偏好优化） 是一种新兴的用于对齐语言模型的技术。与传统的强化学习方法（如RLHF）不同，DPO不依赖于奖励模型或强化学习的复杂机制，而是通过直接利用人类偏好数据来优化模型，使模型生成的输出更加符合人类的期望。\n1. DPO 的基本概念 在 RLHF（Reinforcement Learning from Human Feedback） 中，首先需要用人类反馈训练一个奖励模型，之后通过强化学习来优化语言模型的策略。相比之下，DPO 跳过了这个复杂的过程，直接基于人类偏好对模型进行优化，简化了训练步骤并减少了计算成本。\n2. DPO 的核心机制 DPO 的核心思想是通过直接偏好反馈来训练模型。其步骤如下：\n1. 收集偏好数据 在 DPO 中，首先需要从人类标注员那里收集偏好数据。这些数据通过让人类比较多个模型生成的输出，选择他们认为“更好”的结果，构建成“偏好对”（preference pairs）。每一组偏好数据包含：\n输入（例如一个问题或任务指令） 多个模型生成的响应（这些响应基于输入生成） 人类的偏好选择（标注员选择认为更好的响应） 例如，如果模型生成了两个输出，标注员会选择其中一个作为更优结果，形成一个二元偏好对。\n2. 构建优化目标：偏好概率模型 DPO 直接利用人类的偏好反馈来优化模型。它通过引入一个偏好概率模型，该模型通过比较两个输出生成的概率，来优化更符合人类偏好的输出。具体来说，给定两个模型输出的偏好对，DPO 通过最大化人类选择的“更好”响应的生成概率来训练模型。\n假设我们有两个输出：\n输出1（人类偏好）：$y_1$ 输出2（人类不偏好）：$y_2$ 对于这两个输出，DPO 使用以下概率模型来表示人类选择某个输出的概率：\n$$ P(y_1 \\,|\\, x) = \\frac{\\exp(\\pi_\\theta(x, y_1))}{\\exp(\\pi_\\theta(x, y_1)) + \\exp(\\pi_\\theta(x, y_2))} $$这里：\n$x$ 是输入，$y_1$ 和 $y_2$ 是模型生成的两个响应。 $\\pi_\\theta(x, y)$ 是模型的生成得分函数（可以理解为模型对特定输出的信心得分，或称为“对数概率”）。 这个概率模型表示人类选择 $y_1$ 的概率与它的生成得分成正比。 3. 损失函数：最大化正确偏好概率 DPO 的优化目标是通过最大化人类偏好的选择概率来调整模型参数。对于每一个偏好对，DPO 希望模型能够生成让人类偏好的那个输出 $y_1$ 的概率最大。因此，DPO 构建的损失函数为：\n$$ L(\\theta) = -\\log P(y_1 \\,|\\, x) $$该损失函数会使得在偏好数据中被人类选择的输出（$y_1$）的生成概率不断增大，最终模型会倾向于生成更符合人类偏好的输出。\n4. 训练过程 DPO 使用偏好对数据进行训练的具体步骤如下：\n输入采样：给定一组输入，模型会生成多个可能的输出（即候选响应）。 人类偏好选择：人类标注员会从这些输出中选择更好的一个作为优选输出。 构建损失：根据人类的选择，构建损失函数。模型更新的目标是最大化人类偏好的响应生成概率，同时最小化不被偏好响应的生成概率。 参数更新：使用反向传播算法，基于偏好对数据调整模型参数，使得模型在未来能够生成更符合人类偏好的结果。 3. 优势函数的消除 与 RLHF 不同的是，DPO 并不需要通过奖励模型计算优势函数（advantage function）。在 RLHF 中，优势函数用于评估当前策略输出的相对优越性，而 DPO 直接使用偏好对中的二元选择进行优化，减少了对中间步骤的依赖。\n4. 相对偏好学习 DPO 实质上是一种相对偏好学习。它并不要求绝对的“正确”答案，而是只需要模型根据偏好对中较为优选的结果进行优化。这种相对偏好学习方式降低了对标注数据的要求，因为它不需要明确的标签，而只需要“更好”或“更差”的相对比较。\n5. 与对比学习的关系 DPO 在一定程度上类似于对比学习（Contrastive Learning），因为它依赖于比较多个候选输出，并通过最大化正确响应相对其他响应的优势来训练模型。不同的是，DPO 不需要对比所有可能的候选输出，而是仅在一对候选输出中进行优化。\n6. 总结：DPO 的工作流程 数据收集：人类标注员为同一输入选择两个候选输出，形成偏好对。 概率建模：通过构建选择优选响应的概率模型，计算两个候选响应的概率比。 损失计算：最大化人类偏好的响应的生成概率，构建损失函数。 训练与更新：通过损失函数优化模型参数，使得未来的输出更符合人类的偏好。 DPO 的核心机制在于直接从人类的偏好数据中学习，并通过概率建模和损失函数的设计，简化了对齐模型的训练流程。这使得 DPO 在计算上更加高效，适合于快速对齐任务的场景。\n","date":"2024-10-17T19:20:40+08:00","image":"https://lynnn-yu.github.io/image-20241017165214624.png","permalink":"https://lynnn-yu.github.io/p/rlhf/ppo/dpo%E4%BB%8B%E7%BB%8D/","title":"RLHF/PPO/DPO介绍"},{"content":"做了哪些事情？ 1.对齐调整究竟如何改变基础 LLM？我们通过检查基础 LLM 与其对齐对应物（例如 Llama-2 和 Llama2-chat）之间的标记分布偏移来分析对齐调整的效果=\u0026gt;对齐调整主要学习采用 AI 助手的语言风格，而回答用户查询所需的知识主要来自基础 LLM 本身。=\u0026gt;验证“表面对齐假说”\n2.URIAL (Untuned LLMs with Restyled In-context ALignment)\n3.为了严格评估不同的对齐方法，我们设计了一个多方面、可解释的评估协议。\n对齐调整(常用SFT+RLHF)究竟如何改变基础 LLM？ Motivation “表面对齐假设”(《LIMA: Less Is More for Alignment》：仅使用 1K 个 SFT 示例也可以实现显着的对齐性能，这表明对齐调整的效果可能是“表面的”)，该假设认为对齐调整可能只是教会基础 LLM 选择一组数据格式来与用户交互。\n=\u0026gt;Question：对齐调整(常用SFT+RLHF)究竟如何改变基础 LLM？\nMethod 检查基础 LLM 和其对齐LLM之间的token distribution shift来分析对齐调整的效果。\n用户的输入为$q = {q_1, q_2, \\dots}$ ，对齐后模型的输出为 $o = {o_1, o_2, \\dots}$。 $P_{\\text{align}}$ 表示在该位置的每一个 token 的概率分布。 在位置 $t$的 token 上下文表示为 $x_t = q + {o_1, \\dots, o_{t-1}}$。 然后将$x_t$ 代入 Base LLM 中，生成一个概率分布 $P_{\\text{base}}$。\n=\u0026gt;如果基础模型学会通过对齐调整来修改其在此上下文中的行为，我们应该观察到 $P_{\\text{base}} $和$P_{\\text{align}}$之间的分布在此位置发生变化。另一方面，如果这两个分布彼此非常相似，则意味着对齐调整对此位置的影响微乎其微。\nAnalysis 知识密集型内容源自未调整的 LLM。 推广：\n对齐仅影响很小一部分 token，主要涉及风格 token，例如话语标记、过渡词和安全免责声明，这些 token 仅占总 token 位置的很小一部分。 对齐对于较早的 token 更为关键。\nbase LLM 已经获得了足够的知识来遵循指令。当给出适当的上下文作为前缀时，它们的结果与对齐的 LLM 非常相似。\n=\u0026gt;对齐调整主要学习采用 AI 助手的语言风格，而回答用户查询所需的知识主要来自基础 LLM 本身。\nURIAL (Untuned LLMs with Restyled In-context ALignment) Motivation 对齐调整(SFT+RLHF)：1.需要大量资源 2.可能会导致忘记基础 LLM 中先前获得的知识\nQ:能在不进行调整的情况下实现对齐吗？\nQ:提示和上下文学习方法能多好地对齐基础 LLM？\n基线无调整对齐方法：零样本模板提示、原始上下文学习 (Few-shot) 、检索增强型 ICL。\nMethod URIAL 可以看作是原始ICL的扩展，分为两个部分：ICL 示例的风格输出和上下文对齐的系统提示。\n简单地说如图所示，作者就是在设计了系统提示，并选择了几组问答示例。这些示例作为上下文提示，被用来指导和改善基础LLMs生成的回答，使其在风格上更符合人类用户的偏好，并且在内容上更加安全、有帮助和具有社会责任感。这些ICL旨在不需要对LLM进行额外的调整训练的前提下，通过精心设计的静态上下文示例来实现改善输出的目的。\nExperiment just-eval-instruct 数据集 为了评估 LLM 在多样化示例集上的对齐情况，我们合并了五个现有数据集：（1）AlpacaEval2，（2）MT-Bench，（3）LIMA，（4）HH-RLHF-redteam和（5）MaliciousInstruct。\nAnalysis 人工评估：\nGPT评估：\nGPT-4 GPT-3.5\nURIAL 的表现优于无需调整对齐的基线方法。\n当基础 LLM 很强时，URIAL 甚至比 SFT 和 RLHF 表现更好。\n对齐的 LLM 可能会忘记知识并变得过于敏感。如图B.1、B.2\nQ：URIAL 对上下文示例的选择敏感吗？\n使用 Mistral-7b 对 URIAL 进行了三个不同示例的测试。我们发现整体性能甚至比默认版本（4.63 vs. 4.64）还要好一点。这表明 URIAL 对所提供的 ICL 示例的变化具有鲁棒性。\nQ：URIAL 能处理多轮对话吗？\n只需将之前的聊天记录作为新的上下文示例附加到 URIAL 中，即可促进多轮聊天。我们在附录 B.3 中提供了一个使用 URIAL 进行多轮对话的案例研究。这表明对齐 LLM 的对话能力可能主要来自基础模型本身。\n总结 URIAL 是一种无需调整即可对齐基础 LLM 的强大基线方法。它极其易于实现且完全可重现，从而有助于开发和评估未来无需调整和基于调整的对齐方法。 URIAL 可以用最小的努力对齐极大的 LM（例如 Llama-2-70b、Falcon-180b）。 对这种极大的模型进行微调需要大量的计算资源和时间；URIAL 无需调整即可对齐它们，从而节省了两者。 URIAL 可用于在预训练过程中频繁评估基础 LLM。它使我们能够在基础 LLM 的预训练阶段监控基础 LLM 的质量。 URIAL 能够根据不同基础 LLM 的对齐潜力对其进行公平比较。 对齐的 LLM 之间的比较不能直接反映其基础对应物的质量，因为调整过程可能有很大差异（例如，数据、超参数等）。 URIAL 可用于探索 LLM 对齐的科学性。它表明我们应该重新考虑当前的对齐实践并提倡更有效的方法。URIAL 使我们能够探测基础 LLM——分析基础 LLM 在预训练期间已经获得的知识和技能，以确定对齐缺少什么，而不是盲目地使用大量数据进行微调并产生不必要的计算成本。 ","date":"2024-10-12T20:13:28+08:00","image":"https://lynnn-yu.github.io/v2-98655f9c2f3260a467bec871b16a9cff_r.jpg","permalink":"https://lynnn-yu.github.io/p/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0the-unlocking-spell-on-base-llms-rethinking-alignment-via-in-context-learning/","title":"阅读笔记：《THE UNLOCKING SPELL ON BASE LLMS RETHINKING ALIGNMENT VIA IN-CONTEXT LEARNING》"},{"content":"Maven 与 Gradle 的区别 Java 世界中主要有三大构建工具：Ant、Maven 和 Gradle。经过几年的发展，Ant 几乎销声匿迹、Maven 也日薄西山，而 Gradle 的发展则如日中天。Maven 的主要功能主要分为 5 点，分别是依赖管理系统、多模块构建、一致的项目结构、一致的构建模型和插件机制。Maven 与 Gradle 在使用中各有千秋，根据使用场景择优用之。\n1. Maven 与 Gradle 对比 maven 要引入依赖 pom.xml\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.5.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 而 Gradle 引入 build.gradle\n1 implementation \u0026#39;org.springframework.boot:spring-boot-starter-web\u0026#39; 优点: Gradle 相当于 Maven 与 Ant 的合体 缺点：对于微服务多项目的子类引用，不如 Maven\nMaven\n项目结构 / 依赖由 pom.xml 定义 生产代码存放在 src/main/java 下 测试代码存放在 src/test/java 下 Gradle\n项目结构 / 依赖由 build.gradle 定义 生产代码存放在 src/main/java 下 测试代码存放在 src/test/java 下 2. 构建流程和生命周期 Maven 三个标准的生命周期 (lifecycle) 最小的运行单元是目标 (goal) 插件可以把自己的目标绑定在生命周期的某个阶段 (phase) 上 Gradle 没有显示的生命周期 最小的运行单元是任务 (task)，任务之间可以相互依赖 可以动态地创建任务 3. 包管理和传递性依赖 Maven\n一个包由 groupId/artifactId/version 确定唯一坐标 包来源于中央仓库 传递性依赖 当某个包的的使用依赖于其他包时，Maven 会自动导入所有的依赖包 Gradle\n使用 Ivy 的构件系统，是 Maven 的构件系统的超集\nAnt ivy 是一个比 Maven 仓库更加广阔的仓库\n与 Maven 仓库兼容\n当出现依赖冲突时\nMaven 依赖解调遵循两个原则，路径最近原则以及定义顺序原则 Mavenc 依赖冲突.png\nGradle 的冲突解析则是选用新的版本 (新的版本一般都会向下兼容)\n总结：\nMaven\n稳定可靠，插件众多。(这么多年版本一直维持在 3.XX，而且很久才发布一次小更新，说明他稳定且 bug 较少) 略显啰嗦，自定义逻辑较麻烦 (Maven 使用 xml 的方式进行配置，xml 的劣势繁琐就会体现在 Maven 上) 大型项目会逐渐遇到性能问题\n使用 Maven 构建的项目都会经过几个生命流程，内部没有缓存机制，项目越来越大重新构建所花费的时间也就越长。 由于 Maven 的开发基本靠社区支持，没有更多的资金用于继续开发维护 Maven，导致开发基本停泻。\nGradle\nGradle 采用代码逻辑的方式进行构建，使得它能更加的灵活。 Gradle 内部存在缓存机制 (当文件输入和输出都没改变的情况下，认为这就是没变的代码，直接进行输出。但当你改变的依赖包版本，它有时并没更新，也是缓存机制的问题)，相比会快些。\n开发活跃，版本太多\n从maven迁移到gradle 因为maven出现的时间比较早，所以基本上所有的java项目都支持maven，但是并不是所有的项目都支持gradle。如果你有需要把maven项目迁移到gradle的想法，那么就一起来看看吧。\n根据我们之前的介绍，大家可以发现gradle和maven从本质上来说就是不同的，gradle通过task的DAG图来组织任务，而maven则是通过attach到phases的goals来执行任务。\n虽然两者的构建有很大的不同，但是得益于gradle和maven相识的各种约定规则，从maven移植到gradle并不是那么难。\n要想从maven移植到gradle，首先要了解下maven的build生命周期，maven的生命周期包含了clean，compile，test，package，verify，install和deploy这几个phase。\n我们需要将maven的生命周期phase转换为gradle的生命周期task。这里需要使用到gradle的Base Plugin，Java Plugin和Maven Publish Plugin。\n先看下怎么引入这三个plugin：\n1 2 3 4 5 plugins { id \u0026#39;base\u0026#39; id \u0026#39;java\u0026#39; id \u0026#39;maven-publish\u0026#39; } clean会被转换成为clean task，compile会被转换成为classes task，test会被转换成为test task，package会被转换成为assemble task，verify 会被转换成为check task，install会被转换成为 Maven Publish Plugin 中的publishToMavenLocal task，deploy 会被转换成为Maven Publish Plugin 中的publish task。\n有了这些task之间的对应关系，我们就可以尝试进行maven到gradle的转换了。\n自动转换 我们除了可以使用 gradle init 命令来创建一个gradle的架子之外，还可以使用这个命令来将maven项目转换成为gradle项目，gradle init命令会去读取pom文件，并将其转换成为gradle项目。\n转换依赖 gradle和maven的依赖都包含了group ID, artifact ID 和版本号。两者本质上是一样的，只是形式不同，我们看一个转换的例子：\n1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 上是一个maven的例子，我们看下gradle的例子怎写：\n1 2 3 dependencies { implementation \u0026#39;log4j:log4j:1.2.12\u0026#39; } 可以看到gradle比maven写起来要简单很多。\n注意这里的implementation实际上是由 Java Plugin 来实现的。\n我们在maven的依赖中有时候还会用到scope选项，用来表示依赖的范围，我们看下这些范围该如何进行转换：\ncompile： 在gradle可以有两种配置来替换compile，我们可以使用implementation或者api。\n前者在任何使用Java Plugin的gradle中都可以使用，而api只能在使用Java Library Plugin的项目中使用。\n当然两者是有区别的，如果你是构建应用程序或者webapp，那么推荐使用implementation，如果你是在构建Java libraries，那么推荐使用api。\nruntime： 可以替换成 runtimeOnly 。\ntest： gradle中的test分为两种，一种是编译test项目的时候需要，那么可以使用testImplementation，一种是运行test项目的时候需要，那么可以使用testRuntimeOnly。\nprovided： 可以替换成为compileOnly。\nimport： 在maven中，import经常用在dependencyManagement中，通常用来从一个pom文件中导入依赖项，从而保证项目中依赖项目版本的一致性。\n在gradle中，可以使用 platform() 或者 enforcedPlatform() 来导入pom文件：\n1 2 3 4 5 6 dependencies { implementation platform(\u0026#39;org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE\u0026#39;) implementation \u0026#39;com.google.code.gson:gson\u0026#39; implementation \u0026#39;dom4j:dom4j\u0026#39; } 比如上面的例子中，我们导入了spring-boot-dependencies。因为这个pom中已经定义了依赖项的版本号，所以我们在后面引入gson的时候就不需要指定版本号了。\nplatform和enforcedPlatform的区别在于，enforcedPlatform会将导入的pom版本号覆盖其他导入的版本号：\n1 2 3 4 5 6 7 8 9 10 11 dependencies { // import a BOM. The versions used in this file will override any other version found in the graph implementation enforcedPlatform(\u0026#39;org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE\u0026#39;) // define dependencies without versions implementation \u0026#39;com.google.code.gson:gson\u0026#39; implementation \u0026#39;dom4j:dom4j\u0026#39; // this version will be overridden by the one found in the BOM implementation \u0026#39;org.codehaus.groovy:groovy:1.8.6\u0026#39; } 转换repositories仓库 gradle可以兼容使用maven或者lvy的repository。gradle没有默认的仓库地址，所以你必须手动指定一个。\n你可以在gradle使用maven的仓库：\n1 2 3 repositories { mavenCentral() } 我们还可以直接指定maven仓库的地址：\n1 2 3 4 5 repositories { maven { url \u0026#34;http://repo.mycompany.com/maven2\u0026#34; } } 如果你想使用maven本地的仓库，则可以这样使用：\n1 2 3 repositories { mavenLocal() } 但是mavenLocal是不推荐使用的，为什么呢？\nmavenLocal只是maven在本地的一个cache，它包含的内容并不完整。比如说一个本地的maven repository module可能只包含了jar包文件，并没有包含source或者javadoc文件。那么我们将不能够在gradle中查看这个module的源代码，因为gradle会首先在maven本地的路径中查找这个module。\n并且本地的repository是不可信任的，因为里面的内容可以轻易被修改，并没有任何的验证机制。\n控制依赖的版本 如果同一个项目中对同一个模块有不同版本的两个依赖的话，默认情况下Gradle会在解析完DAG之后，选择版本最高的那个依赖包。\n但是这样做并不一定就是正确的， 所以我们需要自定义依赖版本的功能。\n首先就是上面我们提到的使用platform()和enforcedPlatform() 来导入BOM（packaging类型是POM的）文件。\n如果我们项目中依赖了某个module，而这个module又依赖了另外的module，我们叫做传递依赖。在这种情况下，如果我们希望控制传递依赖的版本，比如说将传递依赖的版本升级为一个新的版本，那么可以使用dependency constraints：\n1 2 3 4 5 6 7 8 9 10 11 dependencies { implementation \u0026#39;org.apache.httpcomponents:httpclient\u0026#39; constraints { implementation(\u0026#39;org.apache.httpcomponents:httpclient:4.5.3\u0026#39;) { because \u0026#39;previous versions have a bug impacting this application\u0026#39; } implementation(\u0026#39;commons-codec:commons-codec:1.11\u0026#39;) { because \u0026#39;version 1.9 pulled from httpclient has bugs affecting this application\u0026#39; } } } 注意，dependency constraints只对传递依赖有效，如果上面的例子中commons-codec并不是传递依赖，那么将不会有任何影响。\n同时 Dependency constraints需要Gradle Module Metadata的支持，也就是说只有你的module是发布在gradle中才支持这个特性，如果是发布在maven或者ivy中是不支持的。\n上面讲的是传递依赖的版本升级。同样是传递依赖，如果本项目也需要使用到这个传递依赖的module，但是需要使用到更低的版本（因为默认gradle会使用最新的版本），就需要用到版本降级了。\n1 2 3 4 5 6 7 8 dependencies { implementation \u0026#39;org.apache.httpcomponents:httpclient:4.5.4\u0026#39; implementation(\u0026#39;commons-codec:commons-codec\u0026#39;) { version { strictly \u0026#39;1.9\u0026#39; } } } 我们可以在implementation中指定特定的version即可。\nstrictly表示的是强制匹配特定的版本号，除了strictly之外，还有require，表示需要的版本号大于等于给定的版本号。prefer，如果没有指定其他的版本号，那么就使用prefer这个。reject，拒绝使用这个版本。\n除此之外，你还可以使用Java Platform Plugin来指定特定的platform，从而限制版本号。\n最后看一下如何exclude一个依赖：\n1 2 3 4 5 dependencies { implementation(\u0026#39;commons-beanutils:commons-beanutils:1.9.4\u0026#39;) { exclude group: \u0026#39;commons-collections\u0026#39;, module: \u0026#39;commons-collections\u0026#39; } } 多模块项目 maven中可以创建多模块项目：\n1 2 3 4 \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;simple-weather\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;simple-webapp\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 我们可以在gradle中做同样的事情settings.gradle：\n1 2 3 rootProject.name = \u0026#39;simple-multi-module\u0026#39; include \u0026#39;simple-weather\u0026#39;, \u0026#39;simple-webapp\u0026#39; profile和属性 maven中可以使用profile来区别不同的环境，在gradle中，我们可以定义好不同的profile文件，然后通过脚本来加载他们：\nbuild.gradle：\n1 2 3 4 5 6 7 8 9 if (!hasProperty(\u0026#39;buildProfile\u0026#39;)) ext.buildProfile = \u0026#39;default\u0026#39; apply from: \u0026#34;profile-${buildProfile}.gradle\u0026#34; task greeting { doLast { println message } } profile-default.gradle：\n1 ext.message = \u0026#39;foobar\u0026#39; profile-test.gradle：\n1 ext.message = \u0026#39;testing 1 2 3\u0026#39; 我们可以这样来运行：\n1 2 3 4 5 \u0026gt; gradle greeting foobar \u0026gt; gradle -PbuildProfile=test greeting testing 1 2 3 资源处理 在maven中有一个process-resources阶段，可以执行resources:resources用来进行resource文件的拷贝操作。\n在Gradle中的Java plugin的processResources task也可以做相同的事情。\n比如我可以执行copy任务：\n1 2 3 4 task copyReport(type: Copy) { from file(\u0026#34;buildDir/reports/my-report.pdf\u0026#34;) into file(\u0026#34;buildDir/toArchive\u0026#34;) } 更加复杂的拷贝：\n1 2 3 4 5 task copyPdfReportsForArchiving(type: Copy) { from \u0026#34;buildDir/reports\u0026#34; include \u0026#34;*.pdf\u0026#34; into \u0026#34;buildDir/toArchive\u0026#34; } 当然拷贝还有更加复杂的应用。这里就不详细讲解了。\n","date":"2024-09-25T18:44:57+08:00","image":"https://lynnn-yu.github.io/%E5%9B%BE.jpg","permalink":"https://lynnn-yu.github.io/p/maven-%E4%B8%8E-gradle-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%BF%81%E7%A7%BB/","title":"Maven 与 Gradle 的区别与迁移"},{"content":"介绍 1.1 什么是Gradle？ Gradle是一个开源构建自动化工具，专为大型项目设计。它基于DSL（领域特定语言）编写，该语言是用Groovy编写的，使得构建脚本更加简洁和强大。Gradle不仅可以构建Java应用程序，还支持多种语言和技术，例如C++、Python、Android等。\n更多信息和详细文档可以在[Gradle官方网站](Gradle Build Tool)上找到。\n1.2 为什么选择Gradle？ 与其他流行的构建工具（如Maven和Ant）相比，Gradle提供了以下优势：\n性能：Gradle使用它的守护程序和增量构建技术来提高构建速度。 灵活性：Gradle的DSL使你可以编写高度定制化的构建脚本。 可扩展性：Gradle可以通过插件机制轻松扩展，有着丰富的插件生态系统。 Android官方支持：对于Android开发，Google官方推荐使用Gradle作为构建工具。 安装和设置 2.1 前提条件 在安装Gradle之前，你需要确保满足以下前提条件：\n一个有效的Java Development Kit (JDK)安装。Gradle 7.0及以上版本需要JDK版本为8到16。 JAVA_HOME 环境变量已正确设置，指向JDK的安装目录。 2.2 下载和安装Gradle 直接下载：你可以从[Gradle官方下载页面](Gradle | Releases)下载最新版本的Gradle分发包。选择合适的分发包，通常我们使用二进制分发包。 使用包管理器：对于某些操作系统，如macOS，你可以使用Homebrew包管理器来安装： 1 brew install gradle 对于Linux用户，可以使用SDKMAN:\n1 sdk install gradle 解压下载的文件到一个合适的安装位置。 将解压后的路径添加到你的操作系统的PATH变量中，以便从任何位置运行Gradle命令。 2.3 验证安装 要验证你的Gradle安装是否成功，可以在命令行或终端中运行以下命令：\n1 gradle -v 会显示Gradle的版本、Groovy的版本以及JVM版本等详细信息，如下图所示：\n-\u0026ndash;\nGradle基础概念 3.1 项目和任务 在Gradle中，构建是由项目和任务组成的。\n项目：代表你正在构建的东西，可以是一个库、应用程序或者是一个更大的单元，如多模块项目。一个构建可以有一个或多个项目。 任务：表示一个原子的构建操作，例如编译类或创建JAR文件。 3.2 构建脚本 Gradle使用构建脚本来配置和控制构建过程。这些脚本默认使用Groovy或Kotlin DSL编写，并具有特定的文件名，如build.gradle或build.gradle.kts。\n构建脚本定义了项目和任务以及它们之间的关系。\n3.3 依赖管理 Gradle不仅仅是一个构建工具，它还有一个强大的依赖管理系统，允许你声明你的项目依赖的外部库，并自动下载和管理它们。\n3.4 插件 插件扩展了Gradle的功能，使得常见的构建任务和配置变得简单。例如，Java插件为Java项目添加了常见的任务，如编译和打包。\n使用插件通常是通过在构建脚本中声明它们来完成的。例如：\n1 2 3 plugins { id \u0026#39;java\u0026#39; } 3.5 生命周期 Gradle任务有一个生命周期，包括三个阶段：\n初始化：在此阶段，Gradle决定要处理哪些项目。 配置：在此阶段，Gradle构建所有的项目的任务对象。 执行：在此阶段，Gradle运行实际的任务。 创建和运行你的第一个Gradle项目 4.1 初始化项目 你可以使用Gradle的命令行界面创建一个新的项目。例如，要创建一个新的Java应用程序，可以运行以下命令：\n1 gradle init --type java-application 指定一些版本号，就会在当前目录下生成一个新的Java项目。\n4.2 项目结构 上面的命令执行完毕后，会在目录下创建这样的一个结构：\n4.3 编写代码 它默认会在app/src/main/java目录中添加一个简单的App类。\n1 2 3 4 5 6 7 8 public class App { public String getGreeting() { return \u0026#34;Hello World!\u0026#34;; } public static void main(String[] args) { System.out.println(new App().getGreeting()); } } 4.4 构建项目 在项目的根目录中，运行以下命令来构建项目：\n1 gradle build 这会编译Java类、运行任何测试（如果有的话）并创建一个JAR文件。\n4.5 运行应用 如果你已经使用--type java-application来初始化项目，你可以使用以下命令来运行你的应用：\n1 gradle run 你应该会看到Hello World!的输出。\n-\u0026ndash;\nGradle构建脚本基础 5.1 build.gradle文件的作用 build.gradle是Gradle构建的核心。它是一个用Groovy或Kotlin DSL编写的脚本，用于定义项目的构建逻辑。它描述了如何编译和打包代码，如何运行测试，以及如何发布成果物。\n5.2 任务（Tasks） 任务是构建的原子操作。每个任务都代表了构建过程中的一个步骤。例如，编译源代码、运行单元测试、生成文档等。\n1 2 3 4 5 tasks.register(\u0026#39;myTask\u0026#39;) { doLast { println \u0026#39;This is a custom task.\u0026#39; } } 上面的代码定义了一个名为myTask的任务，当其被执行时，会在控制台上打印出消息。我们把这段话复制到刚刚的build.gradle下，然后执行就会打印这句话：\n5.3 依赖（Dependencies） 任务之间可能存在依赖关系。这意味着一个任务可能依赖于其他一个或多个任务的成功执行。\n1 2 3 4 5 6 7 8 9 10 11 12 tasks.register(\u0026#39;taskA\u0026#39;) { doLast { println \u0026#39;Task A is executed.\u0026#39; } } tasks.register(\u0026#39;taskB\u0026#39;) { dependsOn \u0026#39;taskA\u0026#39; doLast { println \u0026#39;Task B is executed.\u0026#39; } } 在上面的例子中，taskB依赖于taskA。当你执行taskB时，首先会执行taskA。如图所示：\n5.4 插件（Plugins） 插件是一种强大的扩展Gradle功能的方式。它们可以提供额外的构建任务，增强现有任务，甚至改变Gradle的核心行为。下面列举了一些常用的插件和它们的作用。\n1 2 3 4 5 plugins { id \u0026#39;java\u0026#39; // Java插件，为Java项目提供编译、测试和打包的任务 id \u0026#39;application\u0026#39; // Application插件，可以创建可运行的应用程序，提供了‘run’任务来运行应用 id \u0026#39;war\u0026#39; // War插件，用于构建Java Web应用程序，提供了生成WAR文件的任务 } Java插件 java插件是最基础的插件之一，提供了用于Java项目的核心任务，如compileJava来编译Java源代码和test来运行测试。\nApplication插件 application插件扩展了java插件，提供了创建可执行Java应用程序所需的功能。最重要的是，它添加了run任务，允许你直接从Gradle运行你的应用。\nWar插件 war插件是为Java Web应用程序设计的，用于生成WAR文件，这是Java EE和Servlet容器通常使用的部署格式。\n其他插件 Gradle拥有丰富的插件生态系统，包括但不限于Android开发、Spring Boot集成、Docker构建等。你可以浏览[Gradle Plugin Portal](Gradle - Plugins)来查找更多可用的插件。\n每个插件都有其独特的配置和用法，因此在使用新插件时，请务必查阅其官方文档，以了解如何正确配置和使用它们。\n不同的插件解决了不同的问题，但它们都遵循着同样的设计原则和配置方式，一旦你熟悉了几个常用插件的用法，就能快速学会使用新的插件。\n常用的Gradle任务 在Gradle中，每一个构建动作都是通过执行一个或多个任务来完成的。当我们引入插件时，这些插件通常会为我们预定义一些任务。以下，我们将深入探讨一些常用的Gradle任务。\n6.1 清理 任务名称: clean\n这是一个非常常用的任务。当执行此任务时，Gradle会删除构建目录，确保下一次构建是从干净的状态开始的。\n使用命令：\n1 gradle clean 6.2 构建 任务名称: build\n此任务是Java插件提供的。当执行此任务时，Gradle会执行完整的构建周期，包括编译、测试等。\n使用命令：\n1 gradle build 6.3 测试 任务名称: test\n该任务也是Java插件提供的。它负责运行项目的单元测试。\n使用命令：\n1 gradle test 6.4 运行 任务名称: run\n为了使用此任务，我们需要引入application插件，并设置主类。\n1 2 3 4 plugins { id \u0026#39;application\u0026#39; } mainClassName = \u0026#39;com.example.Main\u0026#39; 然后，可以使用以下命令来运行应用：\n1 gradle run 依赖管理 在大多数软件项目中，我们通常依赖于第三方库来完成某些功能。Gradle提供了一个强大的依赖管理系统，使得声明、解析和使用这些第三方库变得轻而易举。\n7.1 声明仓库 要使用外部依赖，首先需要告诉Gradle从哪里获取它们。最常用的仓库是Maven Central和JCenter。\n例如，要添加Maven Central仓库，你可以这样写：\n1 2 3 repositories { mavenCentral() } 如果你想使用JCenter仓库：\n1 2 3 repositories { jcenter() } 7.2 声明和使用依赖 一旦设置了仓库，就可以开始添加依赖了。\n例如，要在Java项目中使用Google的Gson库，可以如下添加：\n1 2 3 dependencies { implementation \u0026#39;com.google.code.gson:gson:2.8.6\u0026#39; } 其中，implementation表示这是一个主要的运行时依赖。\n7.3 依赖冲突解决 有时，当你的项目依赖于多个库，并且这些库依赖于相同库的不同版本时，就会发生冲突。Gradle有强大的冲突解决策略，通常会选择最新的版本。\n但如果你需要更精确的控制，可以这样做：\n1 2 3 4 5 configurations.all { resolutionStrategy { force \u0026#39;com.google.code.gson:gson:2.8.5\u0026#39; } } 这将确保项目中使用的Gson库版本为2.8.5，即使其他依赖可能请求了一个不同的版本。\n使用插件 Gradle插件为构建和管理项目提供了额外的功能。从Java到Android，再到Spring Boot，几乎所有的现代框架和平台都有自己的Gradle插件来简化相关任务。\n8.1 常见的插件 Java 插件: 这是最常用的插件之一，它为Java项目提供了编译、测试和打包的功能。 1 2 3 plugins { id \u0026#39;java\u0026#39; } Application 插件: 如果你正在构建一个应用程序，这个插件可以帮助你打包并运行它。 1 2 3 plugins { id \u0026#39;application\u0026#39; } War 插件: 为Web应用程序提供支持，使你能够构建WAR文件。 1 2 3 plugins { id \u0026#39;war\u0026#39; } 8.2 如何应用插件 你已经看到了如何应用一个插件，那么我们将更深入地了解它。插件可以从Gradle插件门户、Maven仓库或本地文件应用。\n从Gradle插件门户应用（目前主流做法，简洁）: 1 2 3 plugins { id \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;2.5.4\u0026#39; } 从Maven仓库应用: 1 2 3 4 5 6 7 8 9 buildscript { repositories { mavenCentral() } dependencies { classpath(\u0026#34;org.springframework.boot:spring-boot-gradle-plugin:2.5.4\u0026#34;) } } apply plugin: \u0026#39;org.springframework.boot\u0026#39; 从本地文件应用: 1 apply from: \u0026#39;other.gradle\u0026#39; 8.3 插件的配置 大多数插件都提供了一组可配置的属性来定制它们的行为。例如，application插件允许你指定应用的主类：\n1 2 3 application { mainClassName = \u0026#39;com.example.Main\u0026#39; } 建议查看官方文档或插件的文档来了解所有可用的配置选项。\n多项目构建 大型应用程序和库通常不仅仅是一个孤立的项目。它们可能由多个子项目组成，每个子项目都负责特定的功能。Gradle支持多项目构建，允许你在一个构建中管理和编译多个项目。\n9.1 设置子项目 在你的主项目目录下，创建一个settings.gradle文件（如果尚未存在），并声明子项目：\n1 include \u0026#39;subproject1\u0026#39;, \u0026#39;subproject2\u0026#39; 此处的subproject1和subproject2是子项目的目录名。\n9.2 配置和执行跨项目的任务 每个子项目都可以有自己的[build.gradle](https://zhida.zhihu.com/search?content_id=234482716\u0026amp;content_type=Article\u0026amp;match_order=6\u0026amp;q=build.gradle\u0026amp;zhida_source=entity)文件，其中定义了该子项目的构建逻辑。但在根项目中，你可以定义影响所有子项目的构建逻辑：\n1 2 3 4 5 6 7 8 9 10 11 subprojects { apply plugin: \u0026#39;java\u0026#39; repositories { mavenCentral() } dependencies { testImplementation \u0026#39;junit:junit:4.12\u0026#39; } } 上面的代码片段将Java插件、Maven Central仓库和JUnit依赖添加到所有子项目中。\n要在所有子项目上执行任务，只需在根目录下运行该任务。例如，运行gradle build将构建所有子项目。\n如果只想在一个特定的子项目上执行任务，可以这样：\n1 gradle :subproject1:build 多项目构建是Gradle的强大特性之一，尤其是对于大型的代码库。通过合适地组织和配置，你可以确保整个代码库的一致性和可维护性。\n自定义任务和扩展 10.1 编写自己的任务 在创建自定义任务时，推荐使用tasks.register方法来注册新的任务。这是一个懒加载的方法，意味着任务只有在真正需要时才会创建。\n1 2 3 4 5 6 7 abstract class HelloTask extends DefaultTask { @TaskAction def sayHello() { println \u0026#39;Hello, Gradle!\u0026#39; } } tasks.register(\u0026#39;hello\u0026#39;, HelloTask) 此处使用abstract关键字是因为Gradle会为任务生成具体的实现。\n运行gradle hello将输出Hello, Gradle!。\n10.2 使用Gradle的API 对于现有的任务，我们通常使用tasks.withType来对某种特定类型的所有任务进行配置：\n1 2 3 tasks.withType(HelloTask).configureEach { // 这里可以为每个HelloTask类型的任务进行配置 } 10.3 扩展的概念 Gradle扩展依然是为项目定义自定义属性的推荐方式。但在新的API中，推荐使用extensions.create的方式：\n1 2 3 4 5 extensions.create(\u0026#39;myExtension\u0026#39;, MyExtension) abstract class MyExtension { String customProperty = \u0026#39;default value\u0026#39; } 通过自定义任务和扩展，你可以使Gradle构建过程更加灵活和强大。它们提供了一种机制，使你可以适应项目的特定需求，同时还能保持构建脚本的可读性和组织性。\n构建缓存和增量构建 构建优化对于大型项目和频繁的构建操作非常关键。Gradle 提供了两个强大的特性来加速构建：构建缓存和增量构建。\n11.1 为什么需要缓存？ 每次运行构建时，都有很多任务是重复的，尤其是在没有对代码或资源做任何修改的情况下。构建缓存的作用是存储已经执行过的任务的输出，以便在将来的构建中重用，从而避免不必要的工作。\n11.2 构建缓存的使用和配置 默认情况下，Gradle 使用本地构建缓存。你可以通过以下方式在项目的 settings.gradle 或 settings.gradle.kts 文件中启用或禁用它：\n1 2 3 4 5 buildCache { local { enabled = true } } 此外，Gradle 也支持远程构建缓存，这在团队开发中非常有用，因为它允许团队成员之间共享构建的输出。\n11.3 增量构建 增量构建是指只对自上次构建以来发生变化的部分进行构建。为了使任务支持增量构建，你需要确保：\n使用@Input和@Output注解来声明任务的输入和输出。 使用@Incremental注解在TaskAction方法上。 Gradle 会自动跟踪这些输入和输出之间的变化，并在可能的情况下只执行所需的工作。\n11.4 示例：增量构建 假设我们有一个任务，该任务将源文件从一个目录复制到另一个目录，并将所有文件的扩展名更改为 .txt。我们可以这样做：\n11.4.1添加一个自定义任务 在 build.gradle 文件的顶部，添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import org.gradle.work.InputChanges abstract class IncrementalCopyTask extends DefaultTask { @InputDirectory abstract DirectoryProperty getSourceDir() @OutputDirectory abstract DirectoryProperty getTargetDir() @TaskAction void executeIncremental(InputChanges inputChanges) { inputChanges.getFileChanges(getSourceDir()).each { change -\u0026gt; switch (change.changeType.name()) { case \u0026#34;ADDED\u0026#34;: case \u0026#34;MODIFIED\u0026#34;: def targetFile = new File(getTargetDir().asFile, change.file.name + \u0026#39;.txt\u0026#39;) change.file.copyTo(targetFile) break case \u0026#34;REMOVED\u0026#34;: new File(getTargetDir().asFile, change.file.name + \u0026#39;.txt\u0026#39;).delete() break } } } } 在 build.gradle 的底部，注册这个任务：\n1 2 3 4 tasks.register(\u0026#39;incrementalCopy\u0026#39;, IncrementalCopyTask) { sourceDir = file(\u0026#39;src/main/resources\u0026#39;) targetDir = file(\u0026#34;$buildDir/output\u0026#34;) } 这样，我们就为 src/main/resources 目录中的文件定义了一个增量复制任务，输出目录是 build/output。\n11.4.2运行任务 为了测试这个任务，你可以首先在 src/main/resources 中创建一些文件，然后运行：\n1 $ gradle incrementalCopy 你会看到这些文件被复制到 build/output 目录，并且它们的扩展名都被更改为 .txt。\n如果你再次运行该任务，不做任何改动，Gradle 会检测到没有任何变化，因此不会执行任何复制操作，这就是增量构建的威力。试试在 src/main/resources 中添加、修改或删除文件，然后再次运行任务。你会看到只有发生变化的文件才会被处理。这就是一个简单的增量构建示例。你可以在此基础上进一步扩展或修改来满足你的实际需求。\nGradle Wrapper的使用 12.1 什么是Gradle Wrapper？ Gradle Wrapper是一个工具，允许你在没有预先安装Gradle的情况下执行构建。这样做的好处是可以确保每个开发者和持续集成工具都使用相同版本的Gradle，避免了“在我的机器上可以运行”这样的问题。Wrapper由一个小的gradlew（Unix系统）或gradlew.bat（Windows系统）脚本和一些库文件组成。\n12.2 为什么要使用Gradle Wrapper？ 版本一致性：确保每个开发者和CI环境都使用相同的Gradle版本。 简化构建过程：开发者无需手动安装特定版本的Gradle。 灵活性：项目可以很容易地切换到新的Gradle版本，只需修改Wrapper配置即可。 12.3 如何设置Gradle Wrapper？ 大部分通过gradle init初始化的新项目默认就包含了Wrapper。但如果你的项目还没有Wrapper，可以很容易地添加：\n1 $ gradle wrapper --gradle-version=7.2 这会为你的项目生成Wrapper脚本和相关配置。\n12.4 如何使用Gradle Wrapper？ 一旦你的项目配置了Wrapper，你应该使用Wrapper脚本来运行所有Gradle任务，而不是直接使用gradle命令。例如：\n在Unix或macOS上：\n1 $ ./gradlew \u0026lt;task\u0026gt; 在Windows上：\n1 \u0026gt; gradlew.bat \u0026lt;task\u0026gt; 如果你看到有人在项目的README或构建指南中推荐使用gradlew而不是gradle，这就是为什么。\n12.5更新Gradle Wrapper的版本 随着Gradle的发展，你可能想要更新项目中的Gradle版本。使用Wrapper，这变得很容易。例如，要更新到Gradle 7.3，你可以运行：\n1 $ ./gradlew wrapper --gradle-version=7.3 这会更新Wrapper使用的Gradle版本，并下载必要的文件。\n总结 Gradle Wrapper是Gradle的一个强大特性，它确保了构建的一致性和简化了开发和CI环境的配置。为你的项目使用Wrapper是一个最佳实践，无论项目大小都推荐这样做。\n参考文献 [云原生—Gradle和Maven性能对比及技术选型](云原生-Gradle和Maven性能对比及技术选型 - 掘金) - 稀土掘金 [Gradle | Releases](Gradle | Releases) - 官方文档 [Gradle | Plugins](Gradle - Plugins) - 官方文档 [Gradle 比 Maven 好为什么用的人少？](Gradle 比 Maven 好为什么用的人少？) - 知乎 [Gradle 快速入门](Gradle 快速入门 - 掘金) [Gradle 详细手册（从入门到入土）](Gradle 详细手册（从入门到入土）) - 稀土掘金 如何使用Gradle管理多模块Java项目 - 知乎 [Android—Gradle教程（一）](Android-Gradle教程（一） - 掘金) - 稀土掘金 [GradleUserGuide](GitHub - DONGChuan/GradleUserGuide: \u0026ldquo;Gradle User Guide\u0026rdquo; Chinese version) - GitHub Github Actions - GitHub ","date":"2024-09-25T18:38:41+08:00","image":"https://lynnn-yu.github.io/%E5%9B%BE.jpg","permalink":"https://lynnn-yu.github.io/p/gradle%E5%85%A5%E9%97%A8%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Gradle入门与使用指南"},{"content":"十大经典排序算法 0、算法概述 0.1 算法分类 十种常见排序算法可以分为两大类：\n比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 0.2 算法复杂度 0.3 相关概念\n稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 **空间复杂度：**是指算法在计算机 内执行时所需存储空间的度量，它也是数据规模n的函数。\n1、冒泡排序（Bubble Sort） 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n1.1 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 1.2 动图演示\n1.3 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 function bubbleSort(arr) { var len = arr.length; for (var i = 0; i \u0026lt; len - 1; i++) { for (var j = 0; j \u0026lt; len - 1 - i; j++) { if (arr[j] \u0026gt; arr[j+1]) { // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr; } 2、选择排序（Selection Sort） 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n2.1 算法描述 n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\n初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 2.2 动图演示 2.3 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function selectionSort(arr) { var len = arr.length; var minIndex, temp; for (var i = 0; i \u0026lt; len - 1; i++) { minIndex = i; for (var j = i + 1; j \u0026lt; len; j++) { if (arr[j] \u0026lt; arr[minIndex]) { // 寻找最小的数 minIndex = j; // 将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } return arr; } 2.4 算法分析 表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。\n3、插入排序（Insertion Sort） 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\n3.1 算法描述 一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：\n从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 3.2 动图演示 3.2 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function insertionSort(arr) { var len = arr.length; var preIndex, current; for (var i = 1; i \u0026lt; len; i++) { preIndex = i - 1; current = arr[i]; while (preIndex \u0026gt;= 0 \u0026amp;\u0026amp; arr[preIndex] \u0026gt; current) { arr[preIndex + 1] = arr[preIndex]; preIndex--; } arr[preIndex + 1] = current; } return arr; } 3.4 算法分析 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n4、希尔排序（Shell Sort） 1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。\n4.1 算法描述 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\n选择一个增量序列t1，t2，…，tk，其中ti\u0026gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 动图演示 4.3 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 修改于 2019-03-06 function shellSort(arr) { var len = arr.length; for (var gap = Math.floor(len / 2); gap \u0026gt; 0; gap = Math.floor(gap / 2)) { // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行 for (var i = gap; i \u0026lt; len; i++) { var j = i; var current = arr[i]; while (j - gap \u0026gt;= 0 \u0026amp;\u0026amp; current \u0026lt; arr[j - gap]) { arr[j] = arr[j - gap]; j = j - gap; } arr[j] = current; } } return arr; } 4.4 算法分析 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　5、归并排序（Merge Sort） 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。\n5.1 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 5.2 动图演示 5.3 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function mergeSort(arr) { var len = arr.length; if (len \u0026lt; 2) { return arr; } var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right) { var result = []; while (left.length\u0026gt;0 \u0026amp;\u0026amp; right.length\u0026gt;0) { if (left[0] \u0026lt;= right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result; } 5.4 算法分析 归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。\n6、快速排序（Quick Sort） 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\n6.1 算法描述 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\n从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 6.2 动图演示 6.3 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class QuickSort { public static void quickSort(int[] arr, int low, int high) { if (low \u0026lt; high) { int pi = partition(arr, low, high); quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } } private static int partition(int[] arr, int low, int high) { int pivot = arr[high]; int i = (low - 1); for (int j = low; j \u0026lt; high; j++) { if (arr[j] \u0026lt; pivot) { i++; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp; return i + 1; } public static void main(String[] args) { int[] arr = {10, 7, 8, 9, 1, 5}; int n = arr.length; quickSort(arr, 0, n - 1); System.out.println(\u0026#34;Sorted array: \u0026#34;); for (int i : arr) { System.out.print(i + \u0026#34; \u0026#34;); } } } 7、堆排序（Heap Sort） 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n7.1 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]\u0026lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 7.2 动图演示 7.3 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) { // 建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i \u0026gt;= 0; i--) { heapify(arr, i); } } function heapify(arr, i) { // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left \u0026lt; len \u0026amp;\u0026amp; arr[left] \u0026gt; arr[largest]) { largest = left; } if (right \u0026lt; len \u0026amp;\u0026amp; arr[right] \u0026gt; arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest); } } function swap(arr, i, j) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } function heapSort(arr) { buildMaxHeap(arr); for (var i = arr.length - 1; i \u0026gt; 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0); } return arr; } 8、计数排序（Counting Sort） 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\n8.1 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 8.2 动图演示 8.3 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function countingSort(arr, maxValue) { var bucket = new Array(maxValue + 1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i \u0026lt; arrLen; i++) { if (!bucket[arr[i]]) { bucket[arr[i]] = 0; } bucket[arr[i]]++; } for (var j = 0; j \u0026lt; bucketLen; j++) { while(bucket[j] \u0026gt; 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr; } 8.4 算法分析 计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。\n9、桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。\n9.1 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 9.2 图片演示 9.3 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 function bucketSort(arr, bucketSize) { if (arr.length === 0) { return arr; } var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i \u0026lt; arr.length; i++) { if (arr[i] \u0026lt; minValue) { minValue = arr[i]; // 输入数据的最小值 } else if (arr[i] \u0026gt; maxValue) { maxValue = arr[i]; // 输入数据的最大值 } } // 桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i \u0026lt; buckets.length; i++) { buckets[i] = []; } // 利用映射函数将数据分配到各个桶中 for (i = 0; i \u0026lt; arr.length; i++) { buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); } arr.length = 0; for (i = 0; i \u0026lt; buckets.length; i++) { insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j \u0026lt; buckets[i].length; j++) { arr.push(buckets[i][j]); } } return arr; } 9.4 算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。\n10、基数排序（Radix Sort） 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。\n10.1 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 10.2 动图演示 10.3 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 var counter = []; function radixSort(arr, maxDigit) { var mod = 10; var dev = 1; for (var i = 0; i \u0026lt; maxDigit; i++, dev *= 10, mod *= 10) { for(var j = 0; j \u0026lt; arr.length; j++) { var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) { counter[bucket] = []; } counter[bucket].push(arr[j]); } var pos = 0; for(var j = 0; j \u0026lt; counter.length; j++) { var value = null; if(counter[j]!=null) { while ((value = counter[j].shift()) != null) { arr[pos++] = value; } } } } return arr; } 10.4 算法分析 基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。\n基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n\u0026raquo;k，因此额外空间需要大概n个左右。\n","date":"2024-09-25T15:21:34+08:00","image":"https://lynnn-yu.github.io/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/849589-20190306165258970-1789860540.png","permalink":"https://lynnn-yu.github.io/p/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"十大经典排序算法"},{"content":"核心接口 一、 Collection 关键方法:\n基本操作：\nadd(E e): 向集合添加一个元素，如果集合因添加而改变（即添加成功），返回 true。 addAll(Collection\u0026lt;? extends E\u0026gt; c): 将指定集合中的所有元素添加到此集合（可选操作）。 clear(): 移除此集合中的所有元素（可选操作）。 contains(Object o): 如果此集合包含指定的元素，则返回 true。 containsAll(Collection\u003c?\u003e c): 如果此集合包含指定集合中的所有元素，则返回 true。 isEmpty(): 如果此集合不包含元素，则返回 true。 iterator(): 返回在此集合的元素上进行迭代的迭代器。 remove(Object o): 从此集合中移除一个元素的单个实例，如果存在的话（可选操作）。 removeAll(Collection\u003c?\u003e c): 移除此集合中那些也包含在指定集合中的所有元素（可选操作）。 retainAll(Collection\u003c?\u003e c): 仅保留此集合中那些也包含在指定集合的元素（可选操作）。 size(): 返回此集合中的元素数。 toArray(): 返回包含此集合中所有元素的数组。 toArray(T[] a): 返回包含此集合中所有元素的数组；返回数组的运行时类型是指定数组的类型。 扩展操作：\nstream(): 返回一个顺序流，其元素是此集合的元素。 parallelStream(): 返回可能是并行的流，其元素是此集合的元素。 spliterator(): 在此集合中创建一个Spliterator。 1. List 概述: List 接口扩展自 Collection 接口，表示有序的集合。它允许重复的元素并且可以精确控制每个元素的位置。\n关键方法:\n基本操作：\nget(int index): 返回列表中指定位置的元素。 set(int index, E element): 替换列表中指定位置的元素，并返回之前在该位置的元素。 add(int index, E element): 在列表的指定位置插入指定元素（可选操作）。 remove(int index): 移除列表中指定位置的元素，并返回该元素（可选操作）。 搜索操作：\nindexOf(Object o): 返回列表中首次出现的指定元素的索引，如果列表不包含此元素，则返回 -1。 lastIndexOf(Object o): 返回列表中最后出现的指定元素的索引，如果列表不包含此元素，则返回 -1。 视图操作：\nlistIterator(): 返回列表中元素的列表迭代器（在列表的所有元素上进行迭代）。 listIterator(int index): 返回列表中元素的列表迭代器，迭代器的起始位置是列表中指定的位置。 subList(int fromIndex, int toIndex): 返回列表中指定的 fromIndex（包含）和 toIndex（不包含）之间的视图。 主要实现: ArrayList, LinkedList, Vector.\n2. Set 概述: Set 接口也是扩展自 Collection，代表没有重复元素的集合。\n关键方法: 与 Collection 接口共享大多数方法，没有额外的特殊方法，但强调了不允许有重复元素的特性。\n例如：\nadd(E e)：添加一个元素 e 到集合中，如果集合已经包含了该元素，则不进行添加操作，并且返回 false。这与 Collection 接口的 add 方法不同，后者允许添加重复的元素。 equals(Object o) 和 hashCode()：Set 接口也特别重视这两个方法的实现，以保持与 Set 语义的一致性。这意味着两个 Set 对象相等的条件是它们包含相同的元素。 主要实现: HashSet, LinkedHashSet, TreeSet.\n3. Queue 概述: Queue 接口扩展自 Collection 用于存储一组元素，元素的添加和移除遵循特定的顺序，比如先进先出（FIFO）。\n关键方法:\n添加元素：\noffer(E e): 尝试将元素 e 添加到队列中。如果成功，则返回 true；如果由于容量限制无法添加，则返回 false。这提供了一种比 add(E e) 更优雅的方式来添加元素，因为 add 方法在无法添加元素时会抛出异常。 移除元素：\npoll(): 移除并返回队列头部的元素。如果队列为空，返回 null。这是一个非阻塞的队列操作，不会抛出异常。 remove(): 从队列中移除并返回头部元素。这个方法与 poll 的区别在于，如果队列为空，它会抛出 NoSuchElementException。 检查元素：\npeek(): 检索但不移除队列的头部元素。如果队列为空，则返回 null。这个方法允许用户在不改变队列状态的情况下查看队列的头部元素。 element(): 检索但不移除队列的头部元素。这个方法与 peek 的区别在于，如果队列为空，它会抛出 NoSuchElementException。 主要实现: LinkedList, PriorityQueue.\n二、 Map 概述: Map 不是 Collection 接口的一部分，它表示键值对的映射。每个键最多只能映射到一个值。\n关键方法:\n基本操作：\nput(K key, V value): 将指定的值与此映射中的指定键关联（可选操作）。如果映射以前包含了该键的映射，则旧值将被替换。 get(Object key): 返回指定键所映射的值，如果此映射不包含该键的映射关系，则返回 null。 remove(Object key): 如果存在一个键的映射关系，则将其从映射中移除（可选操作）。 批量操作：\nputAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m): 将所有的映射关系从指定的映射复制到此映射中（可选操作）。 clear(): 从此映射中移除所有的映射关系（可选操作）。 查询操作：\ncontainsKey(Object key): 如果此映射包含指定键的映射关系，则返回 true。 containsValue(Object value): 如果此映射将一个或多个键映射到指定值，则返回 true。 isEmpty(): 如果此映射不包含键-值映射关系，则返回 true。 size(): 返回此映射中的键-值映射关系的数量。 视图操作：\nkeySet(): 返回此映射中包含的键的 Set 视图。 values(): 返回此映射中包含的值的 Collection 视图。 entrySet(): 返回此映射中包含的映射关系的 Set 视图。该 Set 中的每个元素都是一个实现了 Map.Entry 接口的键值对对象。 Map.Entry 接口\nMap 还定义了一个内部接口 Map.Entry，这个接口表示 Map 中的一个键值对（一个映射关系）。\ngetKey(): 返回与此项对应的键。 getValue(): 返回与此项对应的值。 setValue(V value): 将此项的值替换为指定的值（可选操作）。 主要实现: HashMap, TreeMap, LinkedHashMap.\n数据结构 1. 数组 (Array) 静态数组：Java 中的数组是固定长度的数据结构，用于存储相同类型的数据。它们提供快速的索引访问，但大小不可变。\n常用方法：\n虽然数组自身的方法有限，Java 类库提供了一些工具类，如 Arrays 类，以支持更复杂的数组操作：\n排序: Arrays.sort(array) 方法可以对数组进行排序。 搜索: 使用 Arrays.binarySearch(sortedArray, key) 在已排序的数组中查找特定的元素。 比较: Arrays.equals(array1, array2) 用来比较两个数组的内容是否相等。 填充: Arrays.fill(array, value) 方法可以将特定的值赋给数组中的每个元素。 转换为列表: Arrays.asList(array) 将数组转换为一个固定大小的列表。 复制: Arrays.copyOf(array, newLength) 复制数组到新的数组，可以指定新数组的长度。 打印: Arrays.toString(array) 返回数组内容的字符串表示，便于打印输出。 2. 动态数组 (ArrayList) 1 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); 动态扩容：是 List 接口的一个实现。基于数组实现，但能动态地扩展和缩减大小。主要优点是提供快速的随机访问，同时允许在列表末尾高效地添加或删除元素。\n常用方法：\nadd(E e): 在列表末尾添加一个元素，返回 true。\nadd(int index, E element): 在列表的指定位置添加一个元素。\nremove(Object o): 删除列表中首次出现的指定元素，如果列表包含该元素则返回 true。\nremove(int index): 删除指定索引处的元素，返回被删除的元素。\nget(int index): 返回列表中指定位置的元素。\nset(int index, E element): 替换指定索引处的元素，返回之前在该位置的元素。\nsize(): 返回列表中的元素数。\nisEmpty(): 检查列表是否为空，为空返回 true。\ncontains(Object o): 如果列表包含指定的元素，则返回 true。\nindexOf(Object o): 返回列表中首次出现的指定元素的索引，如果此列表不包含该元素，则返回 -1。\nlastIndexOf(Object o): 返回列表中最后出现的指定元素的索引，如果列表不包含该元素，则返回 -1。\naddAll(Collection\u0026lt;? extends E\u0026gt; c): 将指定集合中的所有元素添加到列表的末尾。\naddAll(int index, Collection\u0026lt;? extends E\u0026gt; c): 将指定集合中的所有元素插入到列表中的指定位置。\nclear(): 移除列表中的所有元素。\nremoveAll(Collection\u003c?\u003e c): 移除列表中包含在指定集合中的所有元素。\nretainAll(Collection\u003c?\u003e c): 仅保留列表中那些也包含在指定集合中的元素。\niterator(): 返回一个在列表元素上进行迭代的迭代器。\nlistIterator(): 返回列表中元素的列表迭代器（可以从任意位置开始迭代）。\nforEach(Consumer\u0026lt;? super E\u0026gt; action): 对每个元素执行给定的操作，这是 Java 8 引入的方法，支持 Lambda 表达式。\ntoArray(): 返回一个包含列表中所有元素的数组。\ntoArray(T[] a): 返回一个包含列表中所有元素的数组；返回的数组的运行时类型是指定数组的类型。\n3. 链表 (LinkedList) 1 2 3 List\u0026lt;Integer\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); //或者，如果你需要使用 LinkedList 作为双端队列（deque）： Deque\u0026lt;Integer\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); 双向链表：是 List 接口的一个实现，也实现了 Deque 接口，使其能够作为一个双向链表使用。每个元素包含两个指针，分别指向前一个和后一个元素，使得在任何位置的插入和删除操作都很高效，尤其适用于实现队列和栈。\n常用方法：\nList：\nadd(E e): 将元素添加到列表末尾。\nadd(int index, E element): 在指定位置插入元素。\nget(int index): 访问指定位置的元素。\nset(int index, E element): 替换指定位置的元素，返回被替换的元素。\nremove(int index): 移除指定位置的元素，返回被移除的元素。\nremove(Object o): 删除列表中首次出现的指定元素。\niterator() 和 listIterator(): 提供顺序访问列表的迭代器。\nDeque：\noffer(E e): 在队列尾部添加元素，返回是否成功。\nofferFirst(E e) 和 offerLast(E e): 分别在队列的头部和尾部添加元素。\npoll() 和 pollFirst(): 移除并返回队列头部的元素；如果队列为空，则返回 null。\npollLast(): 移除并返回队列尾部的元素；如果队列为空，则返回 null。\npeek() 和 peekFirst(): 查看但不移除队列头部的元素；如果队列为空，则返回 null。\npeekLast(): 查看但不移除队列尾部的元素；如果队列为空，则返回 null。\npush(E e): 将元素推入栈顶（队列头部）。\npop(): 移除并返回栈顶（队列头部）的元素。\n使用场景：\nList 使用场景: 当你需要频繁地在列表中间插入或删除元素时，使用 LinkedList 比 ArrayList 更高效。 Deque 使用场景: 当你需要在两端动态地添加或移除元素，或者实现栈的行为时，LinkedList 提供了必要的操作。 4. 栈 (Stack) 1 Stack\u0026lt;String\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); 后进先出 (LIFO)：继承自 Vector 类继承自 Vector 类。栈是一种后进先出的数据结构，适合处理具有嵌套结构的数据，如表达式求值和语法解析。\n常用方法：\npush(E item): 将一个元素压入栈顶。此方法将元素添加到栈的顶部，并返回压入的元素。 pop(): 移除栈顶元素，并作为此函数的值返回该对象。 peek(): 查看栈顶对象而不移除它。返回栈顶元素，但不从栈中移除它。 empty(): 测试堆栈是否为空。 search(Object o): 返回对象在堆栈中的位置，以 1 为基数。如果对象 o 作为一个项存在于此堆栈中，则返回距离栈顶最近的位置；栈顶位置为 1。如果不在栈中，则返回 -1。 尽管 Stack 类在 Java 中广泛使用，但 Java 官方文档推荐更倾向于使用 Deque 接口来实现栈的功能，例如通过 ArrayDeque 类，因为 Stack 类本身继承自 Vector，其所有的操作都是同步的，这可能在不需要线程安全的应用场景中导致不必要的性能损失。使用 ArrayDeque 可以获得更好的性能：\n1 2 3 4 Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); stack.push(1); // 压入元素 Integer top = stack.peek(); // 查看栈顶元素 Integer element = stack.pop(); // 移除栈顶元素 5. 优先队列/堆 (PriorityQueue) 基于堆结构：元素按优先级排序，允许快速访问当前最高（或最低）优先级的元素，常用于任务调度和带优先级的数据处理。\n常用方法：\nadd(E e) / offer(E e): 向优先队列添加一个元素。这两个方法在功能上几乎相同，用于在优先队列中插入元素。\npeek(): 返回队列头部的元素而不移除它，如果队列为空，则返回 null。\nelement(): 类似于 peek()，但如果队列为空时会抛出异常。\npoll(): 移除并返回队列头部的元素，如果队列为空，则返回 null。\nremove(): 类似于 poll()，但如果队列为空时会抛出异常。\nremove(Object o): 移除队列中的一个特定元素，返回 true 如果元素被成功移除。\nsize(): 返回队列中的元素数量。\nisEmpty(): 检查队列是否为空，为空则返回 true。\nclear(): 清除队列中的所有元素，使队列变为空。\ncomparator(): 返回当前用于比较队列元素的比较器，如果队列按照元素的自然顺序排序，则可能返回 null。\nPriorityQueue 是基于二叉堆实现的，这使得它在插入和删除最小元素（或根据 Comparator 定义的其他顺序）的操作中非常高效，这些操作的时间复杂度为 O(log n)。这种数据结构适合用于需要快速访问最“优先”元素的场合，如任务调度、带优先级的任务处理等。\n6. 哈希表 (HashSet/HashMap) 1 2 HashSet\u0026lt;Type\u0026gt; setName = new HashSet\u0026lt;\u0026gt;(); HashMap\u0026lt;KeyType, ValueType\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); 基于哈希算法：提供快速的数据存取，适用于需要快速查找、插入和删除的场景。无序，不保证元素的顺序。不允许重复元素。\nHashSet常用方法：\nadd(E e): 向集合中添加一个元素，如果元素已存在则不进行添加。\ncontains(Object o): 检查集合是否包含指定的元素，返回 true 或 false。\nremove(Object o): 从集合中移除指定元素，返回 true 如果元素存在且成功移除，返回 false 如果元素不存在。\nsize(): 返回集合中元素的数量。\nisEmpty(): 检查集合是否为空，返回 true 如果集合为空。\nclear(): 清空集合中的所有元素，使集合变为空。\niterator(): 返回集合的迭代器，用于遍历集合中的元素。\nHashMap常用方法：\nput(K key, V value): 将指定的键与值关联。如果键已存在，则更新其对应的值。\nputAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m): 将指定映射中的所有键值对添加到此映射中。\nget(Object key): 根据指定键返回对应的值，如果键不存在则返回 null。\ncontainsKey(Object key): 检查映射是否包含指定的键，返回 true 或 false。\ncontainsValue(Object value): 检查映射是否包含指定的值，返回 true 或 false。\nremove(Object key): 移除指定键及其对应的值，返回被移除的值（如果存在），否则返回 null。\nsize(): 返回映射中键值对的数量。\nisEmpty(): 检查映射是否为空，返回 true 如果映射为空。\nclear(): 清空映射中的所有键值对。\nkeySet(): 返回映射中所有键的集合。\nvalues(): 返回映射中所有值的集合。\nentrySet(): 返回映射中所有键值对的集合（Map.Entry 对象）。\n7. 红黑树 (TreeSet/TreeMap) 1 2 TreeSet\u0026lt;Type\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); TreeMap\u0026lt;KeyType, ValueType\u0026gt; treeMap = new TreeMap\u0026lt;\u0026gt;(); 红黑树(自平衡的二叉查找树)：保证数据元素按照排序规则组织，支持有序遍历和快速搜索。不允许重复元素。\nTreeSet常用方法：\nadd(E e): 向集合中添加一个元素，如果元素已存在，则不进行添加。\ncontains(Object o): 检查集合是否包含指定的元素，返回 true 或 false。\nremove(Object o): 从集合中移除指定元素，返回 true 如果元素存在且成功移除，返回 false 如果元素不存在。\nfirst(): 返回集合中的第一个元素（最小元素）。\nlast(): 返回集合中的最后一个元素（最大元素）。\nhigher(E e): 返回严格大于指定元素的下一个元素。\nlower(E e): 返回严格小于指定元素的上一个元素。\nsubSet(E fromElement, E toElement): 返回指定范围内的视图，包含从 fromElement 到 toElement（不包含 toElement）。\nheadSet(E toElement): 返回小于 toElement 的所有元素的视图。\ntailSet(E fromElement): 返回大于或等于 fromElement 的所有元素的视图。\nsize(): 返回集合中元素的数量。\nisEmpty(): 检查集合是否为空，返回 true 如果集合为空。\nclear(): 清空集合中的所有元素，使集合变为空。\niterator(): 返回集合的迭代器，用于按升序遍历集合中的元素。\nTreeMap常用方法：\nput(K key, V value): 将指定的键与值关联。如果键已存在，则更新其对应的值。\nputAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m): 将指定映射中的所有键值对添加到此映射中。\nget(Object key): 根据指定键返回对应的值，如果键不存在则返回 null。\ncontainsKey(Object key): 检查映射是否包含指定的键，返回 true 或 false。\ncontainsValue(Object value): 检查映射是否包含指定的值，返回 true 或 false。\nremove(Object key): 移除指定键及其对应的值，返回被移除的值（如果存在），否则返回 null。\nfirstKey(): 返回映射中的第一个键（最小键）。\nlastKey(): 返回映射中的最后一个键（最大键）。\nhigher(K key): 返回严格大于指定键的下一个键。\nlower(K key): 返回严格小于指定键的上一个键。\nsubMap(K fromKey, K toKey): 返回指定范围内的视图，包含从 fromKey 到 toKey（不包含 toKey）。\nheadMap(K toKey): 返回小于 toKey 的所有键值对的视图。\ntailMap(K fromKey): 返回大于或等于 fromKey 的所有键值对的视图。\nsize(): 返回映射中键值对的数量。\nisEmpty(): 检查映射是否为空，返回 true 如果映射为空。\nclear(): 清空映射中的所有键值对。\nkeySet(): 返回映射中所有键的集合。\nvalues(): 返回映射中所有值的集合。\nentrySet(): 返回映射中所有键值对的集合（Map.Entry 对象）。\n8. 链式哈希集合(LinkedHashSet) 1 LinkedHashSet\u0026lt;Type\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); 其中，Type 是要存储的元素类型（如 Integer、String 等）\n**基于哈希表和双向链表：**保持元素的插入顺序。不允许重复元素。\n常用方法：\nadd(E e): 向集合中添加一个元素，如果元素已存在则不进行添加。\ncontains(Object o): 检查集合是否包含指定的元素，返回 true 或 false。\nremove(Object o): 从集合中移除指定元素，返回 true 如果元素存在且成功移除，返回 false 如果元素不存在。\nsize(): 返回集合中元素的数量。\nisEmpty(): 检查集合是否为空，返回 true 如果集合为空。\nclear(): 清空集合中的所有元素，使集合变为空。\niterator(): 返回集合的迭代器，用于按插入顺序遍历集合中的元素。\n9. 图 (Graph) 节点加边的集合：Java 标准库中没有内置的 Graph 类。如果需要使用图数据结构，通常需要自己实现一个图类，或者使用第三方库（如 JGraphT）来处理图的操作。自定义图类可以根据具体需求（如无向图、有向图、加权图等）进行实现和扩展。\n图的简单实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import java.util.*; class Graph\u0026lt;V\u0026gt; { private Map\u0026lt;V, List\u0026lt;V\u0026gt;\u0026gt; adjacencyList; public Graph() { adjacencyList = new HashMap\u0026lt;\u0026gt;(); } // 添加顶点 public void addVertex(V vertex) { adjacencyList.putIfAbsent(vertex, new LinkedList\u0026lt;\u0026gt;()); } // 添加边 public void addEdge(V vertex1, V vertex2) { addVertex(vertex1); addVertex(vertex2); adjacencyList.get(vertex1).add(vertex2); adjacencyList.get(vertex2).add(vertex1); // 无向图 } // 获取所有顶点 public Set\u0026lt;V\u0026gt; getVertices() { return adjacencyList.keySet(); } // 获取所有边 public List\u0026lt;String\u0026gt; getEdges() { List\u0026lt;String\u0026gt; edges = new ArrayList\u0026lt;\u0026gt;(); for (V vertex : adjacencyList.keySet()) { for (V neighbor : adjacencyList.get(vertex)) { edges.add(vertex + \u0026#34; - \u0026#34; + neighbor); } } return edges; } } // 使用示例 public class Main { public static void main(String[] args) { Graph\u0026lt;String\u0026gt; graph = new Graph\u0026lt;\u0026gt;(); graph.addVertex(\u0026#34;A\u0026#34;); graph.addVertex(\u0026#34;B\u0026#34;); graph.addEdge(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;); graph.addEdge(\u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;); System.out.println(\u0026#34;Vertices: \u0026#34; + graph.getVertices()); System.out.println(\u0026#34;Edges: \u0026#34; + graph.getEdges()); } } ","date":"2024-09-22T16:15:06+08:00","image":"https://lynnn-yu.github.io/%E5%9B%BE.jpg","permalink":"https://lynnn-yu.github.io/p/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E4%B8%80%E8%A7%88/","title":"Java集合框架：数据结构及常用操作一览"},{"content":"在 Spring MVC 中，Model 用于在控制器和视图之间传递数据。当你在控制器方法中使用 model.addAttribute() 添加数据时，这些数据会自动被传递到视图（如 Thymeleaf、JSP 等），并在视图中通过模型属性的名字进行访问。\nModel 传参的具体流程 1.控制器方法传递数据到视图：\n在控制器中，使用 model.addAttribute() 方法将一个对象添加到 Model。 Spring MVC 会将这个对象作为请求属性传递给视图（比如 Thymeleaf 模板）。 视图渲染时，可以通过模型中提供的属性来访问并显示数据。 示例代码： 1 2 3 4 5 6 @GetMapping(\u0026#34;/types/input\u0026#34;) public String input(Model model) { // 创建一个新的 Type 对象，并通过 addAttribute 将其放入 Model 中 model.addAttribute(\u0026#34;type\u0026#34;, new Type()); return \u0026#34;admin/types-input\u0026#34;; // 返回视图名 } ​ 在上面的代码中，model.addAttribute(\u0026quot;type\u0026quot;, new Type()) 将一个 Type 对象存储在模型中，键名为 \u0026quot;type\u0026quot;。\n2.视图中获取和使用模型数据：\n在视图模板中（例如 Thymeleaf），你可以通过指定的键名来访问 Model 中的数据。键名是 addAttribute 中的第一个参数（如 \u0026quot;type\u0026quot;），通过这个键名，视图可以使用绑定的对象进行显示或表单字段的初始化。 示例 Thymeleaf 视图（admin/types-input.html）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Type Input\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Input Type\u0026lt;/h1\u0026gt; \u0026lt;!-- 表单绑定到 type 对象的 name 属性 --\u0026gt; \u0026lt;form th:action=\u0026#34;@{/types/save}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Type Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; th:field=\u0026#34;*{name}\u0026#34; placeholder=\u0026#34;Enter type name\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; th:field=\u0026quot;*{name}\u0026quot; 这里的 *{name} 表示从 Model 中绑定的 type 对象的 name 属性。 Spring MVC 自动将 Type 对象放入 Model 中，所以 Thymeleaf 模板能够直接访问 Type 对象的属性。 当页面加载时，th:field 会预先将 type.name 的值显示在表单中（如果有值）。在提交表单时，输入的数据会绑定到 Type 对象的 name 属性。 Model 的传递过程 1. 数据存入 Model： 在控制器方法中调用 model.addAttribute(\u0026quot;type\u0026quot;, new Type())，将键值对存入 Model。 这里 \u0026quot;type\u0026quot; 是键，new Type() 是对应的值（对象）。 2. 传递到视图： Spring MVC 将模型中的所有键值对放入 HTTP 请求的属性中，传递到视图层。 模型中的数据自动与视图解析器（如 Thymeleaf、JSP）关联，视图模板可以通过模型中的键名来访问对象。 3. 视图访问模型数据： 在视图模板中，可以通过 type 键名直接访问绑定的 Type 对象，并且可以使用这个对象来填充表单字段、显示数据，或进行其他操作。 具体示例：完整的控制器与视图交互 1. 控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Controller public class TypeController { @GetMapping(\u0026#34;/types/input\u0026#34;) public String input(Model model) { // 创建一个新的 Type 对象，传递给视图 model.addAttribute(\u0026#34;type\u0026#34;, new Type()); return \u0026#34;admin/types-input\u0026#34;; // 返回视图名称 } @PostMapping(\u0026#34;/types/save\u0026#34;) public String save(@ModelAttribute Type type) { // 在这里处理保存操作，Type 对象会自动绑定表单提交的数据 System.out.println(\u0026#34;Saved Type: \u0026#34; + type.getName()); return \u0026#34;redirect:/types/list\u0026#34;; // 重定向到类型列表页面 } } 2. 视图模板（admin/types-input.html） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Type Input\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Input Type\u0026lt;/h1\u0026gt; \u0026lt;!-- 使用 th:field 来绑定 type 对象的 name 属性 --\u0026gt; \u0026lt;form th:action=\u0026#34;@{/types/save}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt;Type Name:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; th:field=\u0026#34;*{name}\u0026#34; placeholder=\u0026#34;Enter type name\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 总结 Model 在控制器和视图之间扮演了数据传递的桥梁。 在控制器中，你可以通过 model.addAttribute() 将数据传递给视图，视图模板可以通过指定的键名访问这些数据。 这种方式通常用于表单提交的场景，视图层会根据控制器传递的对象进行表单数据的绑定和显示。 ","date":"2024-09-20T20:15:06+08:00","image":"https://lynnn-yu.github.io/%E5%9B%BE.jpg","permalink":"https://lynnn-yu.github.io/p/spring-mvc-%E4%B8%AD%E7%9A%84model/","title":"Spring MVC 中的Model"},{"content":"Optional\u0026lt;T\u0026gt; 是 Java 8 引入的一个容器类，用来解决 null 引用的问题。它可以包含或不包含一个非空值。Optional 主要用于避免 NullPointerException，使代码更加安全和可读。\n创建 Optional 对象 有几种方式可以创建一个 Optional 对象：\n1. Optional.of(T value) 这个方法用于创建包含非空值的 Optional 对象。如果传入的值为 null，它会抛出 NullPointerException。\n1 Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); 2. Optional.ofNullable(T value) 这个方法允许传入一个可能为 null 的值。如果值为 null，它会返回一个空的 Optional 对象；否则返回一个包含该值的 Optional。\n1 Optional\u0026lt;String\u0026gt; optional = Optional.ofNullable(null); // 空的 Optional Optional\u0026lt;String\u0026gt; optional2 = Optional.ofNullable(\u0026#34;Hello\u0026#34;); // 包含 \u0026#34;Hello\u0026#34; 的 Optional 3. Optional.empty() 创建一个空的 Optional 对象，不包含任何值。\n1 Optional\u0026lt;String\u0026gt; optional = Optional.empty(); 使用 Optional 的常用方法 1. isPresent() 检查 Optional 是否包含值。如果值存在，返回 true，否则返回 false。\n1 2 3 4 Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); if (optional.isPresent()) { System.out.println(optional.get()); // 输出 \u0026#34;Hello\u0026#34; } 2. ifPresent(Consumer\u0026lt;? super T\u0026gt; action) 如果 Optional 中包含值，就执行给定的 Consumer 操作，否则不执行。\n1 optional.ifPresent(value -\u0026gt; System.out.println(value)); // 输出 \u0026#34;Hello\u0026#34; 3. orElse(T other) 如果 Optional 中包含值，返回该值；如果为空，则返回一个默认值。\n1 2 String value = optional.orElse(\u0026#34;Default Value\u0026#34;); System.out.println(value); // 输出 \u0026#34;Hello\u0026#34; 或 \u0026#34;Default Value\u0026#34; 4. orElseGet(Supplier\u0026lt;? extends T\u0026gt; other) 类似于 orElse()，但可以通过传递 Supplier 来动态生成默认值。\n1 2 String value = optional.orElseGet(() -\u0026gt; \u0026#34;Generated Value\u0026#34;); System.out.println(value); // 输出 \u0026#34;Hello\u0026#34; 或 \u0026#34;Generated Value\u0026#34; 5. orElseThrow(Supplier\u0026lt;? extends X\u0026gt; exceptionSupplier) 如果 Optional 中包含值，返回该值；如果为空，抛出自定义的异常。\n1 String value = optional.orElseThrow(() -\u0026gt; new IllegalArgumentException(\u0026#34;No value present\u0026#34;)); 6. get() 返回 Optional 中包含的值。如果为空，则抛出 NoSuchElementException。\n1 2 Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); System.out.println(optional.get()); // 输出 \u0026#34;Hello\u0026#34; 注意：使用 get() 之前应当确保 Optional 中有值，可以配合 isPresent() 或者 ifPresent() 来避免异常。\n7. map(Function\u0026lt;? super T,? extends U\u0026gt; mapper) 如果 Optional 中存在值，则对其应用 Function 并返回新的 Optional，否则返回空的 Optional。\n1 2 3 Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); Optional\u0026lt;Integer\u0026gt; length = optional.map(String::length); System.out.println(length.get()); // 输出 5 8. flatMap(Function\u0026lt;? super T, Optional\u0026lt;U\u0026gt;\u0026gt; mapper) 与 map() 类似，但 mapper 返回的是一个 Optional，而不是直接返回值，用于嵌套的 Optional 解包。\n1 2 3 Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); Optional\u0026lt;String\u0026gt; result = optional.flatMap(value -\u0026gt; Optional.of(value.toUpperCase())); System.out.println(result.get()); // 输出 \u0026#34;HELLO\u0026#34; 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.Optional; public class Main { public static void main(String[] args) { // 创建一个 Optional 包含 \u0026#34;Hello\u0026#34; Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Hello\u0026#34;); // 检查值是否存在 if (optional.isPresent()) { System.out.println(\u0026#34;Value is present: \u0026#34; + optional.get()); } // 使用 orElse 方法获取值或默认值 String value = optional.orElse(\u0026#34;Default Value\u0026#34;); System.out.println(\u0026#34;The value is: \u0026#34; + value); // 使用 map 转换值 Optional\u0026lt;Integer\u0026gt; length = optional.map(String::length); System.out.println(\u0026#34;Length of the string is: \u0026#34; + length.get()); // 使用 flatMap 链式操作 Optional\u0026lt;String\u0026gt; result = optional.flatMap(val -\u0026gt; Optional.of(val.toUpperCase())); System.out.println(\u0026#34;Uppercased value: \u0026#34; + result.get()); } } 总结 Optional 是一个非常有用的工具，可以有效避免 null 引用问题，增强代码的可读性和健壮性。通过合理使用 Optional 的各种方法，你可以更好地管理代码中的空值处理逻辑。\n","date":"2024-09-20T17:15:06+08:00","image":"https://lynnn-yu.github.io/%E5%9B%BE.jpg","permalink":"https://lynnn-yu.github.io/p/java%E4%B8%AD%E7%9A%84optional%E7%B1%BB/","title":"Java中的Optional类"},{"content":"JpaRepository 是 Spring Data JPA 中的一个接口，提供了对数据库实体进行CRUD（Create, Read, Update, Delete）操作的常用方法。它继承自 PagingAndSortingRepository 和 CrudRepository，并且提供了一些额外的 JPA 相关的功能。\n使用 JpaRepository 的基本步骤 1. 创建实体类 首先，你需要定义一个实体类并使用 @Entity 注解来标记它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 import javax.persistence.Entity; import javax.persistence.Id; @Entity public class User { @Id private Long id; private String name; private String email; // getters and setters } 2. 创建 JpaRepository 接口 你需要创建一个接口，并让它继承 JpaRepository，其中泛型参数为 \u0026lt;EntityClass, IDType\u0026gt;，即实体类的类型和其主键类型。\n1 2 3 4 5 import org.springframework.data.jpa.repository.JpaRepository; public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { // 你可以在这里添加自定义查询方法 } UserRepository 接口继承了 JpaRepository，这样你就可以直接使用很多内置的方法。\n3. 使用 JpaRepository 提供的内置方法 JpaRepository 为我们提供了很多内置的操作方法，比如：\nsave(S entity)：保存实体对象。 findById(ID id)：通过主键查找实体。 findAll()：获取所有实体。 deleteById(ID id)：通过主键删除实体。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; import java.util.Optional; @Service public class UserService { @Autowired private UserRepository userRepository; public List\u0026lt;User\u0026gt; getAllUsers() { return userRepository.findAll(); } public Optional\u0026lt;User\u0026gt; getUserById(Long id) { return userRepository.findById(id); } public User saveUser(User user) { return userRepository.save(user); } public void deleteUser(Long id) { userRepository.deleteById(id); } } 自定义查询方法 除了 JpaRepository 提供的内置方法，你还可以在接口中定义自定义查询方法，Spring Data JPA 会根据方法名称自动生成查询。\n例如：\n1 2 3 4 5 6 7 8 9 10 import java.util.List; public interface UserRepository extends JpaRepository\u0026lt;User, Long\u0026gt; { // 自定义方法：通过用户名查找用户 List\u0026lt;User\u0026gt; findByName(String name); // 自定义方法：通过邮箱查找用户 User findByEmail(String email); } JpaRepository 常见内置方法 save(S entity)：保存或更新实体。 delete(T entity)：删除实体。 findAll()：查询所有实体。 findById(ID id)：根据ID查找实体。 count()：返回实体总数。 existsById(ID id)：检查某个实体是否存在。 总结 JpaRepository 是一个非常强大的接口，能够简化很多数据库操作。通过它，你可以轻松地完成对数据库的增删改查，并且可以自定义查询方法，极大地提升了开发效率。\n","date":"2024-09-20T16:15:06+08:00","image":"https://lynnn-yu.github.io/%E5%9B%BE.jpg","permalink":"https://lynnn-yu.github.io/p/spring-data-jpa-%E7%9A%84jparepository/","title":"Spring Data JPA 的JpaRepository"},{"content":"Floyd 判圈算法（Floyd’s Cycle Detection Algorithm） 什么是 Floyd 判圈算法？ Floyd 判圈算法，也叫 龟兔赛跑算法（Tortoise and Hare Algorithm），是一种用于检测链表中是否存在环的算法。该算法由 Robert W. Floyd 提出，旨在通过两个不同速度的指针遍历链表来判断链表是否存在循环。其时间复杂度为 O(n)，空间复杂度为 O(1)，因此在效率和资源占用方面非常优越。\n算法原理 Floyd 判圈算法使用两个指针：\n慢指针（Tortoise）：每次移动一步。 快指针（Hare）：每次移动两步。 如果链表中存在环，那么快指针和慢指针最终会在环中相遇。如果链表中不存在环，快指针会先到达链表的末端。\n主要步骤如下： 初始化两个指针：慢指针 slow 和快指针 fast 都指向链表的头部。 快指针每次移动两步，慢指针每次移动一步。 如果快指针和慢指针在某个时刻相遇，则说明链表中存在环。 如果快指针到达 null（链表的末尾），则说明链表中没有环。 代码实现 下面是使用 Python 实现的 Floyd 判圈算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def has_cycle(head): slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next # 慢指针每次移动一步 fast = fast.next.next # 快指针每次移动两步 if slow == fast: # 如果相遇，则存在环 return True return False # 如果遍历结束没有相遇，则不存在环 示例解释 假设我们有一个链表，如下所示：\n1 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; 2 (环) 在此例中，节点 5 指向节点 2，形成了一个环。使用上述代码，快慢指针最终会在环中相遇，从而检测出链表中存在环。\n算法复杂度分析 时间复杂度：O(n)，其中 n 是链表的节点数量。虽然快指针每次走两步，但整体仍然是线性时间复杂度，因为每个节点最多会被访问两次。 空间复杂度：O(1)，因为该算法只使用了两个额外的指针，不需要额外的空间存储其他数据。 应用场景 Floyd 判圈算法主要用于检测链表中的环，但它在其他问题中也能发挥作用，例如：\n图的遍历中用于检测循环路径。 编译器中检测循环依赖。 动态数据结构中检测重复模式或回路。 总结 Floyd 判圈算法是一种高效且简单的算法，适用于检测链表中的环。相比于其他算法，它的优势在于时间复杂度和空间复杂度的平衡。在解决链表环问题时，这个算法是首选之一。如果你正在处理链表结构或者需要在图结构中寻找循环，Floyd 算法将是一个强大的工具。\n","date":"2024-09-20T14:15:06+08:00","image":"https://lynnn-yu.github.io/%E5%9B%BE.jpg","permalink":"https://lynnn-yu.github.io/p/floyd-%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95/","title":"Floyd 判圈算法"},{"content":"$\\textcolor{GreenYellow}{GreenYellow} $ $\\textcolor{Yellow}{Yellow}$ $\\textcolor{Goldenrod}{Goldenrod} $ $\\textcolor{Dandelion}{Dandelion}$ $\\textcolor{Apricot}{Apricot} $ $\\textcolor{Peach}{Peach}$ $\\textcolor{Melon}{Melon} $ $\\textcolor{YellowOrange}{YellowOrange}$ $\\textcolor{Orange}{Orange} $ $\\textcolor{BurntOrange}{BurntOrange}$ $\\textcolor{Bittersweet}{Bittersweet}$ $\\textcolor{RedOrange}{RedOrange} $ $\\textcolor{Mahogany}{Mahogany}$ $\\textcolor{Maroon}{Maroon} $ $\\textcolor{BrickRed}{BrickRed}$ $\\textcolor{Red}{Red} $ $\\textcolor{OrangeRed}{OrangeRed}$ $\\textcolor{RubineRed}{RubineRed}$ $\\textcolor{WildStrawberry}{WildStrawberry}$ $\\textcolor{Salmon}{Salmon}$ $\\textcolor{CarnationPink}{CarnationPink}$ $\\textcolor{Magenta}{Magenta} $ $\\textcolor{VioletRed}{VioletRed}$ $\\textcolor{Rhodamine}{Rhodamine} $ $\\textcolor{Mulberry}{Mulberry}$ $\\textcolor{RedViolet}{RedViolet} $ $\\textcolor{Fuchsia}{Fuchsia}$ $\\textcolor{Lavender}{Lavender} $ $\\textcolor{Thistle}{Thistle}$ $\\textcolor{Orchid}{Orchid} $ $\\textcolor{DarkOrchid}{DarkOrchid}$ $\\textcolor{Purple}{Purple} $ $\\textcolor{Plum}{Plum}$ $\\textcolor{Violet}{Violet} $ $\\textcolor{RoyalPurple}{RoyalPurple}$ $\\textcolor{BlueViolet}{BlueViolet}$ $\\textcolor{Periwinkle}{Periwinkle}$ $\\textcolor{CadetBlue}{CadetBlue}$ $\\textcolor{CornflowerBlue}{CornflowerBlue}$ $\\textcolor{MidnightBlue}{MidnightBlue}$ $\\textcolor{NavyBlue}{NavyBlue} $ $\\textcolor{RoyalBlue}{RoyalBlue}$ $\\textcolor{Blue}{Blue} $ $\\textcolor{Cerulean}{Cerulean}$ $\\textcolor{Cyan}{Cyan} $ $\\textcolor{ProcessBlue}{ProcessBlue}$ $\\textcolor{SkyBlue}{SkyBlue} $ $\\textcolor{Turquoise}{Turquoise}$ $\\textcolor{TealBlue}{TealBlue} $ $\\textcolor{Aquamarine}{Aquamarine}$ $\\textcolor{BlueGreen}{BlueGreen} $ $\\textcolor{Emerald}{Emerald}$ $\\textcolor{JungleGreen}{JungleGreen}$ $\\textcolor{SeaGreen}{SeaGreen} $ $\\textcolor{Green}{Green}$ $\\textcolor{ForestGreen}{ForestGreen}$ $\\textcolor{PineGreen}{PineGreen} $ $\\textcolor{LimeGreen}{LimeGreen}$ $\\textcolor{YellowGreen}{YellowGreen}$ $\\textcolor{SpringGreen}{SpringGreen}$ $\\textcolor{OliveGreen}{OliveGreen}$ $\\textcolor{RawSienna}{RawSienna} $ $\\textcolor{Sepia}{Sepia}$ $\\textcolor{Brown}{Brown} $ $\\textcolor{Tan}{Tan}$ $\\textcolor{Gray}{Gray} $ $\\textcolor{Black}{Black}$\n","date":"0001-01-01T00:00:00Z","permalink":"https://lynnn-yu.github.io/p/","title":""}]